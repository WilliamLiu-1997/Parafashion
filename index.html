<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Parafashion</title>
  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css" />
  <script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
  <script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>

<style>
  ::-webkit-scrollbar {
    width: 1px;
    height: 5px;
    background-color: #F5F5F5;

  }

  ::-webkit-scrollbar-track {
    -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    background-color: #555;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 10px;
    -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3);
    background-color: #F5F5F5;
  }

  * {
    font-family: "Comic Sans MS";
  }

  body {
    font-family: Monospace;
    background-color: #000;
    color: #fff;
    margin: 0px;
    overflow: hidden;
    scrollbar-width: none;
  }

  #info {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    user-select: none;
  }

  canvas {
    width: 100%;
    height: 100%;
  }

  div.panel_box {
    position: absolute;
    top: 10%;
    width: 20%;
    min-width: 216px;
    height: 80%;
    z-index: 2;
    text-align: center;

  }

  .btn:active.focus,
  .btn:active:focus,
  .btn:focus {
    outline: 0px auto -webkit-focus-ring-color;
    outline-offset: 2px;
  }

  #my-gui-container {
    position: absolute;
    top: 10%;
    right: 0px;
    z-index: 1;
  }

  #alert_container {
    position: absolute;
    top: 0%;
    left: 50%;
    transform: translate(-50%, 0);
    z-index: 99;
  }
</style>

<body>
  <div id="container"></div>
  <div id="my-gui-container"></div>
  <div id="alert_container"></div>
  <div id="panel_box" class="panel_box">

    <div class="btn-group" style="width: 100%;">
      <button id="hide-patches" type="button" class="btn btn-default" data-toggle="collapse"
        data-target="#panel-patches" style="
          background-color: rgba(182, 182, 182, 0.75);
          color: #fff;
          padding: 2px;
          width:90%;
        " onclick="hidePatches()">
        Hide Patches
      </button>
      <button id="scale-patches" type="button" class="btn btn-default" style="
          background-color: rgba(182, 182, 182, 0.75);
          color: #fff;
          padding: 2px;
          width:10%;
        " onclick="scalePatches()">
        >
      </button>
    </div>
    <div id="panel-patches" class="panel-collapse collapse in" style="background-color: rgba(0, 0, 0, 0.75)">
      <div id="container_patch">
      </div>
    </div>
  </div>
  <div id="info">
    <p>
      Parafashion<br />
    </p>
  </div>
  <script>
    function hidePatches() {
      $("#panel-patches").on("show.bs.collapse", function () {
        $("#hide-patches").text("Hide Patches");
        $("#scale-patches").css({ "color": "#fff" });
      });
      $("#panel-patches").on("hide.bs.collapse", function () {
        $("#hide-patches").text("Show Patches");
        $("#scale-patches").css({ "color": "#aaa" });
        if ($("#scale-patches").text() == "<") {
          $(".panel_box").animate({ width: '20%' }, 300, scale_icon());
        }
      });
    }
    function scalePatches() {
      if ($("#hide-patches").text() != "Show Patches" && $("#scale-patches").text() != "<") {
        $(".panel_box").animate({ width: '80%' }, 300, scale_icon());
      }
      else if ($("#hide-patches").text() != "Show Patches" && $("#scale-patches").text() == "<") {
        $(".panel_box").animate({ width: '20%' }, 300, scale_icon());
      }
    }
    function scale_icon() {
      if ($("#scale-patches").text() != "<") $("#scale-patches").text("<")
      else $("#scale-patches").text(">")
    }
  </script>
  <script src="./three.js/build/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script type="module">

    import { OBJLoader } from "./three.js/examples/jsm/loaders/OBJLoader.js";
    import { MTLLoader } from "./three.js/examples/jsm/loaders/MTLLoader.js";
    import { EffectComposer } from './three.js/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from './three.js/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from './three.js/examples/jsm/postprocessing/ShaderPass.js';
    import { OutlinePass } from './three.js/examples/jsm/postprocessing/OutlinePass.js';
    import { FXAAShader } from './three.js/examples/jsm/shaders/FXAAShader.js';
    import { GUI } from './three.js/examples/jsm/libs/dat.gui.module.js';
    import Stats from './three.js/examples/jsm/libs/stats.module.js';

    let camera, cameralight, controls, scene, renderer, garment, gui, gui_values, env_light, gui_options, stats;
    let camera_patch, cameralight_patch, controls_patch, scene_patch, renderer_patch, patch, env_light_patch;
    let drawing = false, cut = false, cover = true;
    let obj3D = new THREE.Object3D();
    let progress_obj = -2, progress_mtl = -2;
    let position_folder = false;
    let patch_panel_width = $("#container_patch").css("width");
    let raycaster = new THREE.Raycaster();
    let pointer = new THREE.Vector2();
    let color = new THREE.Color();
    let original_material = [];
    let selected = [], selected_patch = [];
    let mouse_down = false;
    let covered_obj = new THREE.Mesh();
    let covered_obj_patch = new THREE.Mesh();
    let selected_obj = new THREE.Mesh();
    let selected_obj_patch = new THREE.Mesh();
    let last_cover = [];
    let last_select = [];


    let composer, outlinePass, outlinePass_select, effectFXAA, composer_patch, outlinePass_patch, outlinePass_patch_select, effectFXAA_patch;

    let outlinePass_params_cover = {
      edgeStrength: 2.0,
      edgeGlow: 1,
      edgeThickness: 0.5,
      pulsePeriod: 0,
      rotate: false,
      usePatternTexture: false
    };

    let outlinePass_params_select = {
      edgeStrength: 2.0,
      edgeGlow: 0.5,
      edgeThickness: 1,
      pulsePeriod: 4,
      rotate: false,
      usePatternTexture: false
    };

    let texture_map_params = {
      offsetX: 0,
      offsetY: 0,
      repeatX: 1,
      repeatY: 1,
      rotation: 0,
      centerX: 0.5,
      centerY: 0.5
    };

    let texture_normalMap_params = {
      offsetX: 0,
      offsetY: 0,
      repeatX: 1,
      repeatY: 1,
      rotation: 0,
      centerX: 0.5,
      centerY: 0.5
    };

    init();
    init_patch();
    animate();


    function init() {

      if (window.innerWidth < 1080) {
        $("#alert_container").html('<div class="alert alert-warning fade in"><a href="#" class="close" data-dismiss="alert">&times;</a><strong><b>Warning!&nbsp;</b></strong>Your window width is too small. This web application is <b>NOT</b> compatible!&nbsp;&nbsp;</div>');
      }
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x282828);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById("container").appendChild(renderer.domElement);
      stats = new Stats();
      document.getElementById("container").appendChild(stats.dom);

      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.01,
        1000
      );
      camera.position.set(0, 0, 10);

      cameralight = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.8);

      camera.add(cameralight);
      scene.add(camera);
      env_light = new THREE.AmbientLight(0x282828);
      scene.add(env_light);

      // postprocessing
      composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
      composer.addPass(outlinePass);
      outlinePass.edgeStrength = outlinePass_params_cover.edgeStrength;
      outlinePass.edgeThickness = outlinePass_params_cover.edgeThickness;
      outlinePass.edgeGlow = outlinePass_params_cover.edgeGlow;
      outlinePass.pulsePeriod = outlinePass_params_cover.pulsePeriod;
      outlinePass.visibleEdgeColor.set("#aa5555");
      outlinePass.hiddenEdgeColor.set("#221111");

      outlinePass_select = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
      composer.addPass(outlinePass_select);
      outlinePass_select.edgeStrength = outlinePass_params_select.edgeStrength;
      outlinePass_select.edgeThickness = outlinePass_params_select.edgeThickness;
      outlinePass_select.edgeGlow = outlinePass_params_select.edgeGlow;
      outlinePass_select.pulsePeriod = outlinePass_params_select.pulsePeriod;
      outlinePass_select.visibleEdgeColor.set("#ffffff");
      outlinePass_select.hiddenEdgeColor.set("#555555");

      effectFXAA = new ShaderPass(FXAAShader);
      effectFXAA.uniforms['resolution'].value.set(0.1 / window.innerWidth, 0.1 / window.innerHeight);
      composer.addPass(effectFXAA);
      // controls

      controls = new THREE.OrbitControls(camera, renderer.domElement);

      controls.enableDamping = true;
      controls.dampingFactor = 0.1;
      controls.rotateSpeed = 0.2;
      controls.screenSpacePanning = false;
      controls.minDistance = 0.1;
      controls.maxDistance = 200;
      controls.mouseButtons = { ORBIT: THREE.MOUSE.MIDDLE, ZOOM: false, PAN: THREE.MOUSE.RIGHT };

      var garments_obj = "./leggins/leggins_patch.obj";
      var garments_mtl = "./leggins/leggins_patch.obj.mtl";
      var garments_mtl = "./leggins/patch.mtl"
      var garments_obj = "./leggins/patch.obj"
      var garments_mtl = "./obj/village1/village_final.mtl"
      var garments_obj = "./obj/village1/village_final.obj"
      var garments_mtl = "./obj/tower/tower1.mtl"
      var garments_obj = "./obj/tower/tower1.obj"
      // var garments_mtl = "./obj/city2/city2.mtl"
      // var garments_obj = "./obj/city2/city2.obj"
      garment = obj_loader(garments_obj, garments_mtl, 1, true);
      scene.add(garment);

      scene.add(covered_obj);


      const helper = new THREE.GridHelper(1000, 200);
      helper.position.y = -2.5;
      helper.material.opacity = 0.1;
      helper.material.transparent = true;
      scene.add(helper);
      //
      window.addEventListener("resize", onWindowResize);
      window.addEventListener("mousedown", onmouseDown, false);
      window.addEventListener("mouseup", onmouseUp, false);
    }


    function init_patch() {
      scene_patch = new THREE.Scene();
      renderer_patch = new THREE.WebGLRenderer({ alpha: true, antialias: true });

      renderer_patch.setPixelRatio(window.devicePixelRatio);
      renderer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.76);
      document.getElementById("container_patch").appendChild(renderer_patch.domElement);
      camera_patch = new THREE.PerspectiveCamera(
        45,
        $("#container_patch").width() / window.innerHeight / 0.76,
        0.01,
        2000
      );
      camera_patch.position.set(0, 0, 10);

      cameralight_patch = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.8);
      camera_patch.add(cameralight_patch);
      scene_patch.add(camera_patch);
      env_light_patch = new THREE.AmbientLight(0x303030);
      scene_patch.add(env_light_patch);

      composer_patch = new EffectComposer(renderer_patch);
      const renderPass_patch = new RenderPass(scene_patch, camera_patch);
      composer_patch.addPass(renderPass_patch);

      outlinePass_patch = new OutlinePass(new THREE.Vector2($("#container_patch").width(), window.innerHeight * 0.76), scene_patch, camera_patch);
      composer_patch.addPass(outlinePass_patch);
      outlinePass_patch.edgeStrength = outlinePass_params_cover.edgeStrength * 1.5;
      outlinePass_patch.edgeThickness = outlinePass_params_cover.edgeThickness * 1.5;
      outlinePass_patch.edgeGlow = outlinePass_params_cover.edgeGlow;
      outlinePass_patch.pulsePeriod = outlinePass_params_cover.pulsePeriod;
      outlinePass_patch.visibleEdgeColor.set("#aa5555")
      outlinePass_patch.hiddenEdgeColor.set("#221111")

      outlinePass_patch_select = new OutlinePass(new THREE.Vector2($("#container_patch").width(), window.innerHeight * 0.76), scene_patch, camera_patch);
      composer_patch.addPass(outlinePass_patch_select);
      outlinePass_patch_select.edgeStrength = outlinePass_params_select.edgeStrength;
      outlinePass_patch_select.edgeThickness = outlinePass_params_select.edgeThickness;
      outlinePass_patch_select.edgeGlow = outlinePass_params_select.edgeGlow;
      outlinePass_patch_select.pulsePeriod = outlinePass_params_select.pulsePeriod;
      outlinePass_patch_select.visibleEdgeColor.set("#ffffff");
      outlinePass_patch_select.hiddenEdgeColor.set("#555555");

      effectFXAA_patch = new ShaderPass(FXAAShader);
      effectFXAA_patch.uniforms['resolution'].value.set(0.1 / $("#container_patch").width(), 0.1 / window.innerHeight / 0.76);
      composer_patch.addPass(effectFXAA_patch);

      controls_patch = new THREE.OrbitControls(camera_patch, renderer_patch.domElement);

      controls_patch.enableDamping = true;
      controls_patch.dampingFactor = 0.1;
      controls_patch.rotateSpeed = 0.2;
      controls_patch.screenSpacePanning = false;
      controls_patch.minDistance = 0.1;
      controls_patch.maxDistance = 1000;
      controls_patch.enableRotate = false;

      controls_patch.mouseButtons = { ORBIT: THREE.MOUSE.MIDDLE, ZOOM: false, PAN: THREE.MOUSE.RIGHT };

      // controls_patch.maxPolarAngle = Math.PI * 0.9;
      // controls_patch.minPolarAngle = Math.PI * 0.1;
      // controls_patch.maxAzimuthAngle = Math.PI * 0.4;
      // controls_patch.minAzimuthAngle = -Math.PI * 0.4;


      scene_patch.add(covered_obj_patch);

      gui_values = new (function () {
        this.garnment_x = 0;
        this.garnment_y = 0;
        this.garnment_z = 0;
        this.patch_x = 0;
        this.patch_y = 0;
        this.patch_z = 0;
        this.garnment_scale = 1;
        this.patch_scale = 1;
      })();

      gui_options = {
        Reset_Camera: function () {
          controls.reset();
          controls_patch.reset();
          gui_values.garnment_x = 0;
          gui_values.garnment_y = 0;
          gui_values.garnment_z = 0;
          gui_values.patch_x = 0;
          gui_values.patch_y = 0;
          gui_values.patch_z = 0;
          gui_values.garnment_scale = 1;
          gui_values.patch_scale = 1;
          if (gui) { gui.updateDisplay() }
        },
        Unselect: function () {
          select_recovery();
          if (gui) { gui.updateDisplay() }
        }
      }

    }


    function animate() {
      stats.begin();
      if (patch_panel_width != $("#container_patch").css("width")) {
        patch_panel_width = $("#container_patch").css("width")
        onWindowResize()
      }
      if (progress_obj + progress_mtl == 200) {
        var lack = false;
        var all_empty = true;
        progress_obj = progress_mtl = -1;
        var num = garment.children[0].children.length;
        var uvs = []
        for (var i = 0; i < num; i++) {
          try {
            var empty = true;
            var uvarray = garment.children[0].children[i].geometry.attributes.uv.array
            uvs.push(uvarray);
            if (!all_empty || i == 0) {
              for (var uv_index in uvarray) {
                if (uvarray[uv_index] != 0 && uvarray[uv_index] != 1) {
                  empty = false;
                }
              }
            }
            !empty ? all_empty = false : all_empty = true;
          }
          catch (err) {
            console.warn(err + ". Using empty UVs instead.")
            lack = true
            uvs.push([]);
          }
        }
        if (lack || all_empty) { $("#alert_container").html('<div class="alert alert-warning fade in"><a href="#" class="close" data-dismiss="alert">&times;</a><strong><b>Warning!&nbsp;</b></strong>The imported model lacks of partial UVs. This means that the patches we can get are <b>NOT</b> complete!&nbsp;&nbsp;</div>'); }

        patch = patch_loader(garment, uvs, 3, num, false);
        patch.name = "patch"
        scene_patch.add(patch)

        document.addEventListener("mousemove", mouseMove, false);

        gui = new GUI({ width: Math.max(200, window.innerWidth * 0.2), autoPlace: false, scrollable: true })

        document.getElementById('my-gui-container').appendChild(gui.domElement);

        // if (!position_folder) {
        //   position_folder = gui.addFolder("Position and Scale")
        //   position_folder.add(gui_values, "garnment_x", -10, 10, 0.01)
        //   position_folder.add(gui_values, "garnment_y", -10, 10, 0.01)
        //   position_folder.add(gui_values, "garnment_z", -10, 10, 0.01)
        //   position_folder.add(gui_values, "garnment_scale", 0.1, 10, 0.01)
        //   position_folder.add(gui_values, "patch_x", -10, 10, 0.01)
        //   position_folder.add(gui_values, "patch_y", -10, 10, 0.01)
        //   position_folder.add(gui_values, "patch_z", -10, 10, 0.01)
        //   position_folder.add(gui_values, "patch_scale", 0.1, 10, 0.01)
        //   position_folder.open()
        // }

        gui.add(gui_options, 'Reset_Camera');
        gui.add(gui_options, 'Unselect');

      }
      if (progress_obj + progress_mtl == -2) {
        garment.position.set(gui_values.garnment_x, gui_values.garnment_y, gui_values.garnment_z)
        patch.position.set(gui_values.patch_x, gui_values.patch_y, gui_values.patch_z)
        garment.scale.set(gui_values.garnment_scale, gui_values.garnment_scale, gui_values.garnment_scale)
        patch.scale.set(gui_values.patch_scale, gui_values.patch_scale, gui_values.patch_scale)
      }



      requestAnimationFrame(animate);
      controls.update();
      controls_patch.update();
      render();
    }

    function render() {
      composer.render();
      composer_patch.render();
      stats.end();
    }


    function onWindowResize() {
      if (window.innerWidth < 1080) {
        $("#alert_container").html('<div class="alert alert-warning fade in"><a href="#" class="close" data-dismiss="alert">&times;</a><strong><b>Warning!&nbsp;</b></strong>Your window width is too small. This web application is <b>NOT</b> compatible!&nbsp;&nbsp;</div>');
      } else { $("#alert_container").html("") }
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      effectFXAA.uniforms['resolution'].value.set(0.1 / window.innerWidth, 0.1 / window.innerHeight);

      camera_patch.aspect = $("#container_patch").width() / window.innerHeight / 0.76;
      camera_patch.updateProjectionMatrix();
      renderer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.76);
      composer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.76);
      effectFXAA_patch.uniforms['resolution'].value.set(0.1 / $("#container_patch").width(), 0.1 / window.innerHeight / 0.76);

      if (gui) {
        var width = Math.max(216, window.innerWidth * 0.2);
        gui.domElement.style.width = width + 'px';
        gui.__closeButton.style.width = width + 'px';
      }
    }


    function onmouseDown(event) {
      mouse_down = true;
      if (event.button == 0 && cut) {
        drawing = true;
      }
      else if (event.button == 0) {
        let obj = document.getElementById("panel_box");
        pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        pointer.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        if (event.clientX > obj.offsetLeft
          && event.clientX < (obj.offsetLeft + obj.clientWidth)
          && event.clientY > obj.offsetTop
          && event.clientY < (obj.offsetTop + obj.clientHeight)) {
          if (!mouse_down && cover) { cover_recovery(); }
          return;
        }
        if (cover) {
          select_material(pointer, camera);
        }
        cover = false;
      }
      else if (event.button == 1) { cover = false; }
      else if (event.button == 2) { cover = false; }
    }

    function onmouseUp(event) {
      mouse_down = false;
      if (event.button == 0 && cut) {
        drawing = false;
      }
      else if (event.button == 0) {
        cover = true;
        cover_recovery()
      }
      else if (event.button == 1) {
        cover = true;
        cover_recovery()
      }
      else if (event.button == 2) {
        cover = true;
        cover_recovery()
      }
    }


    function cover_recovery() {
      outlinePass.selectedObjects = []
      outlinePass_patch.selectedObjects = []
      last_cover = []
    }

    function select_recovery() {
      outlinePass_select.selectedObjects = []
      outlinePass_patch_select.selectedObjects = []
      last_select = []
    }

    function cover_material(cover_pointer, cover_camera) {
      raycaster.setFromCamera(cover_pointer, cover_camera);
      const intersects = raycaster.intersectObject(garment, true);
      if (intersects.length > 0) {
        // console.log(intersects[ 0 ].face)
        // console.log(intersects[ 0 ].point)
        var group_num = intersects[0].object.geometry.groups.length;
        var vertice_index = intersects[0].face.a;
        var i = 0;
        var num = patch ? patch.children.length : 0;
        if (group_num > 0) {
          for (i = 0; i < group_num; i++) {
            if (intersects[0].object.geometry.groups[i].start <= vertice_index && (vertice_index < (intersects[0].object.geometry.groups[i].start + intersects[0].object.geometry.groups[i].count))) { break; }
          }
          if (last_cover.length != 2 || last_cover[1] != i || last_cover[0] != intersects[0].object) {
            covered_obj.traverse(function (obj) {
              if (obj.type === 'Mesh') {
                obj.geometry.dispose();
                obj.material.dispose();
              }
            })
            scene.remove(covered_obj);
            var this_scale = intersects[0].object.parent.scale;
            var this_position = intersects[0].object.parent.position;
            var g = separateGroups(intersects[0].object.geometry, i)
            covered_obj = new THREE.Mesh(g);
            covered_obj.material.transparent = true;
            covered_obj.material.opacity = 0;
            covered_obj.scale.set(this_scale.x, this_scale.y, this_scale.z);
            covered_obj.position.set(this_position.x, this_position.y, this_position.z);
            scene.add(covered_obj)
            outlinePass.selectedObjects = [covered_obj];
            last_cover = []
            last_cover.push(intersects[0].object, i)

            for (var x = 0; x < num; x++) {
              if (patch && intersects[0].object.name == patch.children[x].name) {
                covered_obj_patch.traverse(function (obj) {
                  if (obj.type === 'Mesh') {
                    obj.geometry.dispose();
                    obj.material.dispose();
                  }
                })
                scene_patch.remove(covered_obj_patch);
                var this_scale = patch.children[x].scale;
                var this_position = patch.children[x].position;
                var g = separateGroups(patch.children[x].geometry, i)
                covered_obj_patch = new THREE.Mesh(g);
                covered_obj_patch.material.transparent = true;
                covered_obj_patch.material.opacity = 0;
                covered_obj_patch.scale.set(this_scale.x, this_scale.y, this_scale.z);
                covered_obj_patch.position.set(this_position.x, this_position.y, this_position.z);
                scene_patch.add(covered_obj_patch)
                outlinePass_patch.selectedObjects = [covered_obj_patch];

                break;
              }
            }
          }
        }
        else {
          if (last_cover.length != 1 || last_cover[0] != intersects[0].object) {
            outlinePass.selectedObjects = [intersects[0].object];
            last_cover = []
            last_cover.push(intersects[0].object)

            for (var x = 0; x < num; x++) {
              if (patch && intersects[0].object.name == patch.children[x].name) {
                outlinePass_patch.selectedObjects = [patch.children[x]];
                break;
              }
            }
          }
        }
      } else { cover_recovery() }
    }


    function select_material(cover_pointer, cover_camera) {
      raycaster.setFromCamera(cover_pointer, cover_camera);
      const intersects = raycaster.intersectObject(garment, true);
      if (intersects.length > 0) {
        // console.log(intersects[ 0 ].face)
        // console.log(intersects[ 0 ].point)
        var group_num = intersects[0].object.geometry.groups.length;
        var vertice_index = intersects[0].face.a;
        var i = 0;
        var num = patch ? patch.children.length : 0;
        if (group_num > 0) {
          for (i = 0; i < group_num; i++) {
            if (intersects[0].object.geometry.groups[i].start <= vertice_index && (vertice_index < (intersects[0].object.geometry.groups[i].start + intersects[0].object.geometry.groups[i].count))) { break; }
          }
          if (last_select.length != 2 || last_select[1] != i || last_select[0] != intersects[0].object) {
            selected = [intersects[0].object.material, i]
            selected_obj.traverse(function (obj) {
              if (obj.type === 'Mesh') {
                obj.geometry.dispose();
                obj.material.dispose();
              }
            })
            scene.remove(selected_obj);
            var this_scale = intersects[0].object.parent.scale;
            var this_position = intersects[0].object.parent.position;
            var g = separateGroups(intersects[0].object.geometry, i)
            selected_obj = new THREE.Mesh(g);
            selected_obj.material.transparent = true;
            selected_obj.material.opacity = 0;
            selected_obj.scale.set(this_scale.x, this_scale.y, this_scale.z);
            selected_obj.position.set(this_position.x, this_position.y, this_position.z);
            scene.add(selected_obj)
            outlinePass_select.selectedObjects = [selected_obj];
            last_select = []
            last_select.push(intersects[0].object, i)

            for (var x = 0; x < num; x++) {
              if (patch && intersects[0].object.name == patch.children[x].name) {
                selected_patch = [patch.children[x].material, i];

                selected_obj_patch.traverse(function (obj) {
                  if (obj.type === 'Mesh') {
                    obj.geometry.dispose();
                    obj.material.dispose();
                  }
                })
                scene_patch.remove(selected_obj_patch);
                var this_scale = patch.children[x].scale;
                var this_position = patch.children[x].position;
                var g = separateGroups(patch.children[x].geometry, i)
                selected_obj_patch = new THREE.Mesh(g);
                selected_obj_patch.material.transparent = true;
                selected_obj_patch.material.opacity = 0;
                selected_obj_patch.scale.set(this_scale.x, this_scale.y, this_scale.z);
                selected_obj_patch.position.set(this_position.x, this_position.y, this_position.z);
                scene_patch.add(selected_obj_patch)
                outlinePass_patch_select.selectedObjects = [selected_obj_patch];
                break;
              }
            }
          }
        }
        else {
          if (last_select.length != 1 || last_select[0] != intersects[0].object) {
            selected = [intersects[0].object];
            outlinePass_select.selectedObjects = [intersects[0].object];
            last_select = []
            last_select.push(intersects[0].object)

            for (var x = 0; x < num; x++) {
              if (patch && intersects[0].object.name == patch.children[x].name) {
                patch.children[x].material = patch.children[x].material.clone();
                selected_patch = [patch.children[x]];
                outlinePass_patch_select.selectedObjects = [patch.children[x]];
                break;
              }
            }
          }
        }
      }
    }

    function mouseMove(event) {
      let obj = document.getElementById("panel_box");
      pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
      pointer.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
      if (event.clientX > obj.offsetLeft
        && event.clientX < (obj.offsetLeft + obj.clientWidth)
        && event.clientY > obj.offsetTop
        && event.clientY < (obj.offsetTop + obj.clientHeight)) {
        if (!mouse_down && cover) { cover_recovery(); }
        return;
      }
      if (drawing) {
      }
      else if (cover) {
        cover_material(pointer, camera);
      }
    }

    function separateGroups(bufGeom, ig) {

      var groups = bufGeom.groups;

      var origVerts = bufGeom.getAttribute('position').array;
      var origNormals = bufGeom.getAttribute('normal').array;
      var origUVs = bufGeom.getAttribute('uv').array;

      var group = groups[ig];

      var destNumVerts = group.count;

      var newBufGeom = new THREE.BufferGeometry();
      var newPositions = new Float32Array(destNumVerts * 3);
      var newNormals = new Float32Array(destNumVerts * 3);
      var newUVs = new Float32Array(destNumVerts * 3);

      for (var iv = 0; iv < destNumVerts; iv++) {

        var indexOrig = 3 * (group.start + iv);
        var indexDest = 3 * iv;

        newPositions[indexDest] = origVerts[indexOrig];
        newPositions[indexDest + 1] = origVerts[indexOrig + 1];
        newPositions[indexDest + 2] = origVerts[indexOrig + 2];

        newNormals[indexDest] = origNormals[indexOrig];
        newNormals[indexDest + 1] = origNormals[indexOrig + 1];
        newNormals[indexDest + 2] = origNormals[indexOrig + 2];

        newUVs[indexDest] = origUVs[indexOrig];
        newUVs[indexDest + 1] = origUVs[indexOrig + 1];
        newUVs[indexDest + 2] = origUVs[indexOrig + 2];

      }

      newBufGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
      newBufGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
      newBufGeom.setAttribute('uv', new THREE.Float32BufferAttribute(newUVs, 3));

      return newBufGeom;

    }


    function updateUvTransform(material) {

      var map = material.map;

      map.offset.set(texture_map_params.offsetX, texture_map_params.offsetY);
      map.repeat.set(texture_map_params.repeatX, texture_map_params.repeatY);
      map.center.set(texture_map_params.centerX, texture_map_params.centerY);
      map.rotation = texture_map_params.rotation;

      var normal_map = material.normalMap;

      normal_map.offset.set(texture_normalMap_params.offsetX, texture_normalMap_params.offsetY);
      normal_map.repeat.set(texture_normalMap_params.repeatX, texture_normalMap_params.repeatY);
      normal_map.center.set(texture_normalMap_params.centerX, texture_normalMap_params.centerY);
      normal_map.rotation = texture_normalMap_params.rotation;

      return material;
    }


    function obj_loader(url_obj, url_mtl, scale, double = false) {
      const onProgress_obj = function (xhr) {
        if (xhr.lengthComputable) {
          const percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded");
          progress_obj = Math.round(percentComplete, 2);
        }
      };
      const onProgress_mtl = function (xhr) {
        if (xhr.lengthComputable) {
          const percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded");
          progress_mtl = Math.round(percentComplete, 2);
        }
      };
      var newobj = obj3D.clone();
      var newmtl = new MTLLoader();
      if (double) {
        newmtl.setMaterialOptions({ side: THREE.DoubleSide });
      }
      newmtl.load(
        url_mtl,
        (mtl) => {
          mtl.preload();
          var objLoader = new OBJLoader();
          objLoader.setMaterials(mtl);
          objLoader.load(
            url_obj,
            function (root) {
              var x_max = -Infinity, x_min = Infinity, y_max = -Infinity, y_min = Infinity, z_max = -Infinity, z_min = Infinity;
              root.traverse(function (child) {
                if (child.geometry) {
                  original_material.push(Array.isArray(child.material) ? array_clone(child.material, true) : child.material.clone())
                  child.castShadow = true;
                  child.receiveShadow = true;
                  child.geometry.computeFaceNormals();
                  for (var i = 0; i < child.geometry.attributes.position.array.length; i++) {
                    if ((i + 1) % 3 == 0) {
                      x_max = x_max < child.geometry.attributes.position.array[i - 2] ? child.geometry.attributes.position.array[i - 2] : x_max
                      x_min = x_min > child.geometry.attributes.position.array[i - 2] ? child.geometry.attributes.position.array[i - 2] : x_min
                      y_max = y_max < child.geometry.attributes.position.array[i - 1] ? child.geometry.attributes.position.array[i - 1] : y_max
                      y_min = y_min > child.geometry.attributes.position.array[i - 1] ? child.geometry.attributes.position.array[i - 1] : y_min
                      z_max = z_max < child.geometry.attributes.position.array[i] ? child.geometry.attributes.position.array[i] : z_max
                      z_min = z_min > child.geometry.attributes.position.array[i] ? child.geometry.attributes.position.array[i] : z_min
                    }
                  }
                }
              })
              var scale_value = Math.max(x_max - x_min, y_max - y_min, z_max - z_min) / 5;
              if(scale_value>1){scale_value/=Math.sqrt(scale_value)}
              root.position.set(-(x_min + x_max) / 2 / scale_value, -y_min / scale_value - 2.5, -(z_min + z_max) / 2 / scale_value);
              root.scale.set(scale / scale_value, scale / scale_value, scale / scale_value);
              newobj.add(root);
            },
            onProgress_mtl
          );
        },
        onProgress_obj
      );
      return newobj;
    }

    function array_clone(array, clone) {
      var result = []
      for (var i = 0; i < array.length; i++) {
        if (clone) result.push(array[i].clone())
        else result.push(array[i])
      }
      return result
    }


    function patch_loader(garment, uv, scale, num, double = false) {
      var newobj = obj3D.clone();
      var last_x = 0;
      for (var x = 0; x < num; x++) {
        var patch = Array.isArray(garment.children[0].children[x].geometry) ? array_clone(garment.children[0].children[x].geometry, true) : garment.children[0].children[x].geometry.clone();
        var patch_mtl = Array.isArray(garment.children[0].children[x].material) ? array_clone(garment.children[0].children[x].material, true) : garment.children[0].children[x].material.clone();

        var vertices = [];
        var normals = [];
        for (var i = 0; i < uv[x].length; i++) {
          if ((i + 1) % 2 == 0) {
            var vertice = new THREE.Vector3();
            vertice.set(uv[x][i - 1], uv[x][i], 0);
            vertices.push(vertice);
          }
          if ((i + 1) % 6 == 0) {
            var x1 = uv[x][i - 5]
            var y1 = uv[x][i - 4]
            var x2 = uv[x][i - 3]
            var y2 = uv[x][i - 2]
            var x3 = uv[x][i - 1]
            var y3 = uv[x][i]
            var a = y3 - y1
            var b = x1 - x3
            var c = x3 * y1 - x1 * y3
            if (a * x2 + b * y2 + c >= 0) {
              normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
            } else {
              normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1);
            }
          }
        }
        patch.setFromPoints(vertices);
        patch.deleteAttribute("normal");
        patch.setAttribute("normal", new THREE.BufferAttribute(new Float32Array(normals), 3));
        var patch_map = new THREE.Mesh(patch, patch_mtl);
        patch_map.name = garment.children[0].children[x].name;

        patch.computeBoundingSphere();
        var radius = patch.boundingSphere.radius * 2;

        last_x = last_x == 0 ? -radius * scale : last_x;
        patch_map.position.set(radius / 2 * scale + last_x, -patch.boundingSphere.center.y * scale, 0);
        //patch_map.rotateZ(Math.PI)
        last_x += radius * 1.5 * scale;
        patch_map.scale.set(scale, scale, scale);

        newobj.add(patch_map);
      }
      return newobj
    }
  </script>
</body>

</html>