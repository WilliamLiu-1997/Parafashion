<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Parafashion</title>
  <link rel="shortcut icon" href="#" />
  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css" />
  <script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
  <script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>

<style>
  ::-webkit-scrollbar {
    width: 2px;
    height: 5px;
    background-color: #F5F5F5;

  }

  ::-webkit-scrollbar-track {
    -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    background-color: #555;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 10px;
    -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3);
    background-color: #F5F5F5;
  }

  body {
    background-color: #000;
    color: #fff;
    margin: 0px;
    overflow: hidden;
    scrollbar-width: none;
  }

  #info {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    user-select: none;
  }

  canvas {
    width: 100%;
    height: 100%;
  }

  div.panel_box {
    position: absolute;
    top: 10%;
    width: 25%;
    min-width: 216px;
    /* height: 80%; */
    z-index: 2;
    text-align: center;

  }

  .btn:active.focus,
  .btn:active:focus,
  .btn:focus {
    outline: 0px auto -webkit-focus-ring-color;
    outline-offset: 2px;
  }

  #gui_container {
    position: absolute;
    height: 80%;
    top: 10%;
    right: 0px;
    z-index: 1;
    user-select: none;
  }


  .alert_container {
    position: absolute;
    top: 1%;
    left: 50%;
    transform: translate(-50%, 0);
    z-index: 99;
  }

  .tip {
    font-size: 12px;
    font-weight: bold;
    text-align: center;
    color: rgb(228, 228, 228);
  }

  .up-area {
    border: 1px dashed rgb(150, 150, 150);
    width: 300px;
    min-height: 50px;
    line-height: 50px;
    background-color: rgba(90, 90, 90, 0);
  }

  img {
    max-width: 100%;
    display: inline-block;
  }

  .texture_container {
    max-height: 45%;
    overflow-y: auto;
  }
</style>

<script src="./three.js/build/three.js"></script>
<script src="js/OrbitControls.js"></script>

<body>
  <div id="container"></div>
  <div id="gui_container">
    <button type="button" class=" btn-default" data-toggle="collapse" data-target="#texture_container" style="
      background-color: rgb(120,120,120);
      border: 1px solid  rgb(180, 180, 180);border-style:none none solid none;
      font-size:12px;
      color: #fff;
      padding: 3px;
      width:100%;
    ">
      Custom Texture
    </button>
    <div id="texture_container" class="texture_container panel-collapse collapse">
      <div class="dragFile">
        <div class="up-area">
          <div class="tip">Click or Drag to upload a texture...</div>
          <input type="file" style="display:none;" id="fileDrag" name="fileDragselect" multiple>
          <div class="list-drag" style="text-align: center;">
          </div>
        </div>
      </div>
    </div>
    <button type="button" class=" btn-default" data-toggle="collapse" data-target="#gui_container_gui" style="
      background-color: rgb(120,120,120);
      border: 1px solid  rgb(180, 180, 180);border-style:none none solid none;
      font-size:12px;
      color: #fff;
      padding: 3px;
      width:100%;
    ">
      Controls
    </button>
    <div id="gui_container_gui" class="panel-collapse collapse in"></div>
  </div>
  <div id="alert_uv" class="alert_container"></div>
  <div id="alert_size" class="alert_container"></div>
  <div id="alert_img" class="alert_container"></div>
  <div id="panel_box" class="panel_box">

    <div id="patch_btn" class="btn-group" style="width: 100%;">
      <button id="hide-patches" type="button" class="btn btn-default" data-toggle="collapse"
        data-target="#panel-patches" style="
          background-color: rgb(120,120,120);
          font-size:12px;
          color: #fff;
          padding: 2px;
          width:90%;
        " onclick="hidePatches()">
        Hide Patches
      </button>
      <button id="scale-patches" type="button" class="btn btn-default" style="
          background-color: rgb(120,120,120);
          font-size:12px;
          color: #fff;
          padding: 2px;
          width:10%;
        " onclick="scalePatches()">
        >
      </button>
    </div>
    <div id="panel-patches" class="panel-collapse collapse in" style="background-color: rgba(0, 0, 0, 0.75)">
      <div id="container_patch">
      </div>
    </div>
  </div>
  <div id="info">
    <p>
      <font size='3'>Parafashion</font><br />
    </p>
  </div>
  <script>
    var render_patch_flag = true;
    function hidePatches() {
      $("#panel-patches").on("show.bs.collapse", function () {
        $("#hide-patches").text("Hide Patches");
        $("#scale-patches").css({ "color": "#fff" });
        $(".panel_box").animate({ width: '25%', minWidth: "216px" });
        $("#scale-patches").text(">");
        render_patch_flag = true;
      });
      $("#panel-patches").on("hide.bs.collapse", function () {
        $("#hide-patches").text("Show Patches");
        $("#scale-patches").css({ "color": "#aaa" });
        $(".panel_box").animate({ width: '5%', minWidth: "120px" });
        $("#scale-patches").text(">");
        render_patch_flag = false;
      });
    }
    function scalePatches() {
      if ($("#hide-patches").text() != "Show Patches" && $("#scale-patches").text() != "<") {
        $(".panel_box").animate({ width: '80%' }, 300);
        $("#scale-patches").text("<");
      }
      else if ($("#hide-patches").text() != "Show Patches" && $("#scale-patches").text() == "<") {
        $(".panel_box").animate({ width: '25%' }, 300);
        $("#scale-patches").text(">");
      }
    }

  </script>
  <script type="module">

    import { GUI } from './js/dat.gui.module.js';
    import { OBJLoader } from "./three.js/examples/jsm/loaders/OBJLoader.js";
    import { MTLLoader } from "./three.js/examples/jsm/loaders/MTLLoader.js";
    import { EffectComposer } from './three.js/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from './three.js/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from './three.js/examples/jsm/postprocessing/ShaderPass.js';
    import { OutlinePass } from './three.js/examples/jsm/postprocessing/OutlinePass.js';
    import { FXAAShader } from './three.js/examples/jsm/shaders/FXAAShader.js';
    import Stats from './three.js/examples/jsm/libs/stats.module.js';

    let camera, cameralight, controls, scene, renderer, garment, gui, env_light, stats;
    let camera_patch, cameralight_patch, controls_patch, scene_patch, renderer_patch, patch, env_light_patch;
    let obj_vertices_count = 0;
    let planeGeometry, planeMaterial, plane, directionalLight, sphere;
    let drawing = false, cover = true;
    let obj3D = new THREE.Object3D();
    let progress_obj = -2, progress_mtl = -2;
    let patch_panel_width = $("#container_patch").css("width");
    let raycaster = new THREE.Raycaster();
    let pointer = new THREE.Vector2();
    let pointer_patch = new THREE.Vector2();
    let color = new THREE.Color();
    let original = [];
    let selected = [], selected_patch = [];
    let mouse_down = false;
    let covered_obj = new THREE.Mesh();
    let covered_obj_patch = new THREE.Mesh();
    let selected_obj = new THREE.Mesh();
    let selected_obj_patch = new THREE.Mesh();
    let last_cover = [];
    let last_cover_patch = [];
    let last_select = [];
    let last_select_patch = [];
    var max_radius = 0;
    var angle = 0;
    let default_texture = new THREE.TextureLoader().load("./texture/default.jpg");
    let default_material = new THREE.MeshPhongMaterial({ color: 0xa0a0a0, emissive: 0x0, reflectivity: 0.3})
    let obj_size = 1;
    let vec3 = new THREE.Vector3();
    let vec2 = new THREE.Vector2();

    var url = ""
    var custom_texture;

    let composer, outlinePass, outlinePass_select, effectFXAA, composer_patch, outlinePass_patch, outlinePass_patch_select, effectFXAA_patch;

    var garments_obj = "./leggins/leggins_patch.obj";
    var garments_mtl = "./leggins/leggins_patch.obj.mtl";
    var garments_mtl = "./leggins/patch.mtl"
    var garments_obj = "./leggins/patch.obj"
    var garments_mtl = "./leggins/patch_smooth.mtl"
    var garments_obj = "./leggins/patch_smooth.obj"
    var garments_mtl = "./obj/village1/village_final.mtl"
    var garments_obj = "./obj/village1/village_final.obj"
    var garments_mtl = "./obj/tower/tower3.mtl"
    var garments_obj = "./obj/tower/tower3.obj"
    // var garments_mtl = "./obj/city2/city2.mtl"
    // var garments_obj = "./obj/city2/city2.obj"
    // var garments_mtl = "./obj/S/S.mtl"
    // var garments_obj = "./obj/S/S.obj"
    //garments_mtl=false

    const format = '.jpg';
    const format_png = '.png';
    const path1 = "./three.js/examples/textures/cube/Park2/";
    const urls1 = [
      path1 + 'posx' + format, path1 + 'negx' + format,
      path1 + 'posy' + format, path1 + 'negy' + format,
      path1 + 'posz' + format, path1 + 'negz' + format
    ];
    const env1 = new THREE.CubeTextureLoader().load(urls1);
    const env1_refre = new THREE.CubeTextureLoader().load(urls1);
    env1_refre.mapping = THREE.CubeRefractionMapping;

    const env2 = new THREE.TextureLoader().load('./texture/11.jpg');
    env2.mapping = THREE.EquirectangularReflectionMapping;
    const env2_refre = new THREE.TextureLoader().load('./texture/11.jpg');
    env2_refre.mapping = THREE.EquirectangularRefractionMapping;

    const env3 = new THREE.TextureLoader().load('./texture/7.jpg');
    env3.mapping = THREE.EquirectangularReflectionMapping;
    const env3_refre = new THREE.TextureLoader().load('./texture/7.jpg');
    env3_refre.mapping = THREE.EquirectangularRefractionMapping;

    const path4 = "./three.js/examples/textures/cube/skyboxsun25deg/";
    const urls4 = [
      path4 + 'px' + format, path4 + 'nx' + format,
      path4 + 'py' + format, path4 + 'ny' + format,
      path4 + 'pz' + format, path4 + 'nz' + format
    ];
    const env4 = new THREE.CubeTextureLoader().load(urls4);
    const env4_refre = new THREE.CubeTextureLoader().load(urls4);
    env4_refre.mapping = THREE.CubeRefractionMapping;

    const path5 = "./three.js/examples/textures/cube/Bridge2/";
    const urls5 = [
      path5 + 'posx' + format, path5 + 'negx' + format,
      path5 + 'posy' + format, path5 + 'negy' + format,
      path5 + 'posz' + format, path5 + 'negz' + format
    ];
    const env5 = new THREE.CubeTextureLoader().load(urls5);
    const env5_refre = new THREE.CubeTextureLoader().load(urls5);
    env5_refre.mapping = THREE.CubeRefractionMapping;

    const env6 = new THREE.TextureLoader().load('./texture/5.jpg');
    env6.mapping = THREE.EquirectangularReflectionMapping;
    const env6_refre = new THREE.TextureLoader().load('./texture/5.jpg');
    env6_refre.mapping = THREE.EquirectangularRefractionMapping;

    const env7 = new THREE.TextureLoader().load('./texture/9.jpg');
    env7.mapping = THREE.EquirectangularReflectionMapping;
    const env7_refre = new THREE.TextureLoader().load('./texture/9.jpg');
    env7_refre.mapping = THREE.EquirectangularRefractionMapping;

    const path8 = "./three.js/examples/textures/cube/Park3Med/";
    const urls8 = [
      path8 + 'px' + format, path8 + 'nx' + format,
      path8 + 'py' + format, path8 + 'ny' + format,
      path8 + 'pz' + format, path8 + 'nz' + format
    ];
    const env8 = new THREE.CubeTextureLoader().load(urls8);
    const env8_refre = new THREE.CubeTextureLoader().load(urls8);
    env8_refre.mapping = THREE.CubeRefractionMapping;

    const env9 = new THREE.TextureLoader().load('./texture/4.jpg');
    env9.mapping = THREE.EquirectangularReflectionMapping;
    const env9_refre = new THREE.TextureLoader().load('./texture/4.jpg');
    env9_refre.mapping = THREE.EquirectangularRefractionMapping;

    const env10 = new THREE.TextureLoader().load('./texture/1.jpg');
    env10.mapping = THREE.EquirectangularReflectionMapping;
    const env10_refre = new THREE.TextureLoader().load('./texture/1.jpg');
    env10_refre.mapping = THREE.EquirectangularRefractionMapping;

    const env11 = new THREE.TextureLoader().load('./texture/2.jpg');
    env11.mapping = THREE.EquirectangularReflectionMapping;
    const env11_refre = new THREE.TextureLoader().load('./texture/2.jpg');
    env11_refre.mapping = THREE.EquirectangularRefractionMapping;

    const env12 = new THREE.TextureLoader().load('./texture/3.jpg');
    env12.mapping = THREE.EquirectangularReflectionMapping;
    const env12_refre = new THREE.TextureLoader().load('./texture/3.jpg');
    env12_refre.mapping = THREE.EquirectangularRefractionMapping;

    const env13 = new THREE.TextureLoader().load('./texture/10.jpg');
    env13.mapping = THREE.EquirectangularReflectionMapping;
    const env13_refre = new THREE.TextureLoader().load('./texture/10.jpg');
    env13_refre.mapping = THREE.EquirectangularRefractionMapping;

    const env14 = new THREE.TextureLoader().load('./texture/6.jpg');
    env14.mapping = THREE.EquirectangularReflectionMapping;
    const env14_refre = new THREE.TextureLoader().load('./texture/6.jpg');
    env14_refre.mapping = THREE.EquirectangularRefractionMapping;

    const env15 = new THREE.TextureLoader().load('./texture/8.jpg');
    env15.mapping = THREE.EquirectangularReflectionMapping;
    const env15_refre = new THREE.TextureLoader().load('./texture/8.jpg');
    env15_refre.mapping = THREE.EquirectangularRefractionMapping;

    
    var environment = {
      Square: env7, Park: env1, PlayingRoom: env2, Alley: env3, Sky: env4, Bridge: env5, Gallery: env6, None: null, Snow: env8, LivingRoom: env12, Street: env10, Church: env11, Restaurant: env13, BedRoom: env9, BathRoom: env14, Town: env15
    }
    var gui_options = {
      Reset_Camera: function () {
        controls.reset();
        controls_patch.reset();
        if (gui) { gui.updateDisplay() }
      },
      Unselect: function () {
        select_recovery();
        cover_recovery();
        if (gui) { gui.updateDisplay() }
      },
      env: "None",
      Rotate: false,
      Enable_Patch_Background: false,
      cut: false,
    }

    let outlinePass_params_cover = {
      edgeStrength: 2.0,
      edgeGlow: 0.5,
      edgeThickness: 1,
      pulsePeriod: 0,
      rotate: false,
      usePatternTexture: false,
      visibleEdgeColor: "#aa5555",
      hiddenEdgeColor: "#221111"
    };

    let outlinePass_params_select = {
      edgeStrength: 3.0,
      edgeGlow: 0.5,
      edgeThickness: 1,
      pulsePeriod: 3.5,
      rotate: false,
      usePatternTexture: false,
      visibleEdgeColor: "#ffffff",
      hiddenEdgeColor: "#333333"
    };

    var texture_wrap = { repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping, clamp: THREE.ClampToEdgeWrapping }
    var TextureParams = {
      wrap: "clamp",
      offsetX: 0,
      offsetY: 0,
      repeatX: 1,
      repeatY: 1,
      rotation: 0,
      centerX: 0.5,
      centerY: 0.5,
    };


    var Materials = {
      //'LineBasicMaterial': THREE.LineBasicMaterial,
      //'LineDashedMaterial': THREE.LineDashedMaterial,
      //'RawShaderMaterial': THREE.RawShaderMaterial,
      //'ShaderMaterial': THREE.ShaderMaterial,
      //'ShadowMaterial': THREE.ShadowMaterial,
      //'SpriteMaterial': THREE.SpriteMaterial,
      //'PointsMaterial': THREE.PointsMaterial
      //'MeshNormalMaterial': {
      //   bumpMap: "None",
      //   bumpScale: 1.0,
      //   displacementMap: "None",
      //   displacementScale: 0.0,
      //   displacementBias: 0.0,
      //   flatShading: false,
      //   morphNormals: false,
      //   morphTargets: false,
      //   normalMap: "None",
      //   normalScale: 1.0,//vector2
      //   wireframe: false,
      // },
      'MeshBasicMaterial': {
        alphaMap: "None",
        alphaWrap: "clamp",
        color: 0xffffff,
        map: "None",
        morphTargets: false,
        reflectivity: 0.5,
        specularMap: "None",
        specularWrap: "clamp",
        wireframe: false,
      },
      'MeshDepthMaterial': {
        alphaMap: "None",
        alphaWrap: "clamp",
        displacementMap: "None",
        displacementBias: 0.0,
        map: "None",
        morphTargets: false,
        wireframe: false,
      },
      'MeshLambertMaterial': {
        alphaMap: "None",
        alphaWrap: "clamp",
        color: 0xffffff,
        emissive: 0x000000,
        emissiveMap: "None",
        emissiveWrap: "clamp",
        emissiveIntensity: 1.0,
        map: "None",
        morphNormals: false,
        morphTargets: false,
        reflectivity: 0.5,
        specularMap: "None",
        specularWrap: "clamp",
        wireframe: false,
      },
      'MeshMatcapMaterial': {
        alphaMap: "None",
        alphaWrap: "clamp",
        bumpMap: "None",
        bumpWrap: "clamp",
        bumpScale: 1.0,
        color: 0xffffff,
        displacementMap: "None",
        displacementWrap: "clamp",
        displacementScale: 0.0,
        displacementBias: 0.0,
        flatShading: false,
        map: "None",
        matcap: "None",
        matcapWrap: "clamp",
        morphNormals: false,
        morphTargets: false,
        normalMap: "None",
        normalWrap: "clamp",
        normalScale: 1.0,//vector2
      },
      'MeshPhongMaterial': {
        alphaMap: "None",
        alphaWrap: "clamp",
        bumpMap: "None",
        bumpWrap: "clamp",
        bumpScale: 1.0,
        color: 0xffffff,
        displacementMap: "None",
        displacementWrap: "clamp",
        displacementScale: 0.0,
        displacementBias: 0.0,
        emissive: 0x000000,
        emissiveMap: "None",
        emissiveWrap: "clamp",
        emissiveIntensity: 1.0,
        flatShading: false,
        map: "None",
        morphNormals: false,
        morphTargets: false,
        normalMap: "None",
        normalWrap: "clamp",
        normalScale: 1.0,//vector2
        reflectivity: 0.5,
        shininess: 30,//0 to 100
        specular: 0x111111,
        specularMap: "None",
        specularWrap: "clamp",
        wireframe: false,
      },
      'MeshToonMaterial': {
        alphaMap: "None",
        alphaWrap: "clamp",
        bumpMap: "None",
        bumpWrap: "clamp",
        bumpScale: 1.0,
        color: 0xffffff,
        displacementMap: "None",
        displacementWrap: "clamp",
        displacementScale: 0.0,
        displacementBias: 0.0,
        emissive: 0x000000,
        emissiveMap: "None",
        emissiveWrap: "clamp",
        emissiveIntensity: 1.0,
        map: "None",
        morphNormals: false,
        morphTargets: false,
        normalMap: "None",
        normalWrap: "clamp",
        normalScale: 1.0,//vector2
        wireframe: false,
      },
      'MeshStandardMaterial': {
        alphaMap: "None",
        alphaWrap: "clamp",
        bumpMap: "None",
        bumpWrap: "clamp",
        bumpScale: 1.0,
        color: 0xffffff,
        displacementMap: "None",
        displacementWrap: "clamp",
        displacementScale: 0.0,
        displacementBias: 0.0,
        emissive: 0x000000,
        emissiveMap: "None",
        emissiveWrap: "clamp",
        emissiveIntensity: 1.0,
        flatShading: false,
        map: "None",
        metalness: 0.0,
        metalnessMap: "None",
        metalnessWrap: "clamp",
        morphNormals: false,
        morphTargets: false,
        normalMap: "None",
        normalWrap: "clamp",
        normalScale: 1.0,//vector2
        roughness: 1.0,
        roughnessMap: "None",
        roughnessWrap: "clamp",
        wireframe: false,
      },
      'MeshPhysicalMaterial': {
        alphaMap: "None",
        alphaWrap: "clamp",
        bumpMap: "None",
        bumpWrap: "clamp",
        bumpScale: 1.0,
        color: 0xffffff,
        displacementMap: "None",
        displacementWrap: "clamp",
        displacementScale: 0.0,
        displacementBias: 0.0,
        emissive: 0x000000,
        emissiveMap: "None",
        emissiveWrap: "clamp",
        emissiveIntensity: 1.0,
        flatShading: false,
        map: "None",
        metalness: 0.0,
        metalnessMap: "None",
        metalnessWrap: "clamp",
        morphNormals: false,
        morphTargets: false,
        normalMap: "None",
        normalWrap: "clamp",
        normalScale: 1.0,//vector2
        roughness: 1.0,
        roughnessMap: "None",
        roughnessWrap: "clamp",
        wireframe: false,
        clearcoat: 0.0,
        clearcoatMap: "None",
        clearcoatWrap: "clamp",
        clearcoatNormalMap: "None",
        clearcoatNormalWrap: "clamp",
        clearcoatNormalScale: 1.0,//vector2
        clearcoatRoughness: 0.0,
        clearcoatRoughnessMap: "None",
        clearcoatRoughnessWrap: "clamp",
        ior: 1.5,//1.0 to 2.333
        reflectivity: 0.5,
        sheen: "None",//color
        transmission: 0.0,
        transmissionMap: "None",
        transmissionWrap: "clamp",
      },
    }

    var Material = {
      material: "MeshPhongMaterial",
      opacity: 1.0,
      transparent: false,
      side: "DoubleSide",
      vertexColors: false,
      visible: true,
    }



    function GUI_init() {
      gui = new GUI({ width: 300, autoPlace: false, scrollable: true })

      document.getElementById('gui_container_gui').appendChild(gui.domElement);

      var folder_basic = gui.addFolder("Basic")
      folder_basic.add(gui_options, 'Reset_Camera').name("Reset Camera");
      folder_basic.add(gui_options, 'Unselect');
      folder_basic.add(gui_options, 'cut').name("Cut Garment").onChange(() => Clean_Cover_select());
      folder_basic.open()

      var folder_env = gui.addFolder("Environment")
      folder_env.add(gui_options, 'Rotate').onChange(() => Show(gui_options.Rotate));
      folder_env.add(gui_options, 'Enable_Patch_Background').name("Patch Background").onChange(() => Display(environment[gui_options.env], gui_options.Enable_Patch_Background));
      folder_env.add(gui_options, "env", ["None", "Sky", "Alley", "LivingRoom", "BedRoom", "PlayingRoom", 'Street', 'Town', "Park", "Snow", "Bridge", "Restaurant"]).name("Background").onChange(() => Display(environment[gui_options.env], gui_options.Enable_Patch_Background))
      // "BathRoom", 'Church', "Gallery", "Square"
      folder_env.open()

      var material_folder = gui.addFolder("Material")
      material_folder.add(Material,"material",[...Object.keys(Materials)])
      material_folder.add(Material,"transparent")
      material_folder.add(Material,"opacity",0,1,0.01)
      material_folder.add(Material,"side",["FrontSide","BackSide","DoubleSide"])
      material_folder.add(Material,"vertexColors")
      material_folder.add(Material,"visible")
      //material_folder.hide()

      

      var folder_custom_map_texture = gui.addFolder("Custom Map Texture")
      folder_custom_map_texture.add(TextureParams, "wrap", ["clamp", "repeat", "mirror"])
      folder_custom_map_texture.add(TextureParams, "offsetX", -10, 10, 0.01)
      folder_custom_map_texture.add(TextureParams, "offsetY", -10, 10, 0.01)
      folder_custom_map_texture.add(TextureParams, "repeatX", 0.1, 10, 0.1)
      folder_custom_map_texture.add(TextureParams, "repeatY", 0.1, 10, 0.1)
      folder_custom_map_texture.add(TextureParams, "rotation", -Math.PI, Math.PI, 0.01)
      folder_custom_map_texture.add(TextureParams, "centerX", -10, 10, 0.01)
      folder_custom_map_texture.add(TextureParams, "centerY", -10, 10, 0.01)
      folder_custom_map_texture.hide()
    }


    function Clean_Cover_select() {
      cover_recovery()
      select_recovery()
    }

    init();
    init_patch();
    GUI_init();
    animate();


    function init() {

      if (window.innerWidth < 1080) {
        $("#alert_size").html('<div class="alert alert-warning fade in"><a href="#" class="close" data-dismiss="alert">&times;</a><strong><b>Warning!&nbsp;</b></strong>Your window width is too small. This web application is <b>NOT</b> compatible!&nbsp;&nbsp;</div>');
      }
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x303030);

      renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById("container").appendChild(renderer.domElement);
      //**********************************************************
      // var editor = new Editor();
      // window.editor = editor;
      // var sidebar = new Sidebar( editor );
      // document.body.appendChild( sidebar.dom );
      // console.log(sidebar.dom)
      //**********************************************************
      stats = new Stats();
      document.getElementById("container").appendChild(stats.dom);

      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.01,
        1000
      );
      camera.position.set(0, 0, 2);

      cameralight = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.8);

      camera.add(cameralight);
      scene.add(camera);
      env_light = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(env_light);


      // postprocessing
      composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
      composer.addPass(outlinePass);
      outlinePass.edgeStrength = outlinePass_params_cover.edgeStrength;
      outlinePass.edgeThickness = outlinePass_params_cover.edgeThickness;
      outlinePass.edgeGlow = outlinePass_params_cover.edgeGlow;
      outlinePass.pulsePeriod = outlinePass_params_cover.pulsePeriod;
      outlinePass.visibleEdgeColor.set(outlinePass_params_cover.visibleEdgeColor);
      outlinePass.hiddenEdgeColor.set(outlinePass_params_cover.hiddenEdgeColor);

      outlinePass_select = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
      composer.addPass(outlinePass_select);
      outlinePass_select.edgeStrength = outlinePass_params_select.edgeStrength;
      outlinePass_select.edgeThickness = outlinePass_params_select.edgeThickness;
      outlinePass_select.edgeGlow = outlinePass_params_select.edgeGlow;
      outlinePass_select.pulsePeriod = outlinePass_params_select.pulsePeriod;
      outlinePass_select.visibleEdgeColor.set(outlinePass_params_select.visibleEdgeColor);
      outlinePass_select.hiddenEdgeColor.set(outlinePass_params_select.visibleEdgeColor);

      effectFXAA = new ShaderPass(FXAAShader);
      effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth / window.devicePixelRatio, 1 / window.innerHeight / window.devicePixelRatio);
      composer.addPass(effectFXAA);
      composer.setPixelRatio(window.devicePixelRatio);
      composer.setSize(window.innerWidth, window.innerHeight);
      // controls

      controls = new THREE.OrbitControls(camera, renderer.domElement);

      controls.enableDamping = true;
      controls.dampingFactor = 0.1;
      controls.rotateSpeed = 0.2;
      controls.autoRotateSpeed = 0.15;
      controls.screenSpacePanning = false;
      controls.minDistance = 0.1;
      controls.maxDistance = 50;
      controls.mouseButtons = { ORBIT: THREE.MOUSE.MIDDLE, ZOOM: false, PAN: THREE.MOUSE.RIGHT };

      garment = obj_loader(garments_obj, garments_mtl, 1, true);
      scene.add(garment);

      scene.add(covered_obj);


      const helper = new THREE.GridHelper(200, 200);
      helper.position.y = -0.5;
      helper.material.opacity = 0.25;
      helper.material.transparent = true;
      scene.add(helper);

      // const geometry = new THREE.SphereGeometry(0.1, 32, 32);
      // const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
      // sphere = new THREE.Mesh(geometry, material);
      // sphere.position.set(-100, 50, -100);
      // sphere.visible = false
      // scene.add(sphere);


      // directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      // directionalLight.position.set(-200, 100, -200);
      // directionalLight.castShadow = true;
      // directionalLight.shadow.camera.near = 0.01;
      // directionalLight.shadow.camera.far = 1500;
      // directionalLight.shadow.camera.left = -15;
      // directionalLight.shadow.camera.right = 15;
      // directionalLight.shadow.camera.top = 15;
      // directionalLight.shadow.camera.bottom = -15;
      // directionalLight.shadow.mapSize.width = 4096;
      // directionalLight.shadow.mapSize.height = 4096;

      // planeGeometry = new THREE.PlaneGeometry(200, 200);
      // planeGeometry.rotateX(- Math.PI / 2);
      // planeMaterial = new THREE.ShadowMaterial({ opacity: 0.2, side: THREE.DoubleSide });
      // plane = new THREE.Mesh(planeGeometry, planeMaterial);
      // plane.position.y = -0.5;
      // plane.receiveShadow = true;
      // scene.add(plane);


      //
      window.addEventListener("resize", onWindowResize);
      window.addEventListener("mousedown", onmouseDown, false);
      window.addEventListener("mouseup", onmouseUp, false);
    }


    function init_patch() {
      scene_patch = new THREE.Scene();
      renderer_patch = new THREE.WebGLRenderer({ alpha: true, antialias: true, logarithmicDepthBuffer: true });

      renderer_patch.setPixelRatio(window.devicePixelRatio);
      renderer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.78);
      document.getElementById("container_patch").appendChild(renderer_patch.domElement);
      camera_patch = new THREE.PerspectiveCamera(
        45,
        $("#container_patch").width() / window.innerHeight / 0.78,
        0.01,
        1000
      );
      camera_patch.position.set(0, 0, 1);

      cameralight_patch = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.8);
      cameralight_patch.position.set(0, 0.5, 0)
      camera_patch.add(cameralight_patch);
      scene_patch.add(camera_patch);
      env_light_patch = new THREE.AmbientLight(0xffffff, 0.2);
      scene_patch.add(env_light_patch);

      composer_patch = new EffectComposer(renderer_patch);
      const renderPass_patch = new RenderPass(scene_patch, camera_patch);
      composer_patch.addPass(renderPass_patch);

      outlinePass_patch = new OutlinePass(new THREE.Vector2($("#container_patch").width(), window.innerHeight * 0.78), scene_patch, camera_patch);
      composer_patch.addPass(outlinePass_patch);
      outlinePass_patch.edgeStrength = outlinePass_params_cover.edgeStrength * 2;
      outlinePass_patch.edgeThickness = outlinePass_params_cover.edgeThickness * 1.5;
      outlinePass_patch.edgeGlow = outlinePass_params_cover.edgeGlow;
      outlinePass_patch.pulsePeriod = outlinePass_params_cover.pulsePeriod;
      outlinePass_patch.visibleEdgeColor.set(outlinePass_params_cover.visibleEdgeColor);
      outlinePass_patch.hiddenEdgeColor.set(outlinePass_params_cover.hiddenEdgeColor);

      outlinePass_patch_select = new OutlinePass(new THREE.Vector2($("#container_patch").width(), window.innerHeight * 0.78), scene_patch, camera_patch);
      composer_patch.addPass(outlinePass_patch_select);
      outlinePass_patch_select.edgeStrength = outlinePass_params_select.edgeStrength * 2;
      outlinePass_patch_select.edgeThickness = outlinePass_params_select.edgeThickness * 1.5;
      outlinePass_patch_select.edgeGlow = outlinePass_params_select.edgeGlow;
      outlinePass_patch_select.pulsePeriod = outlinePass_params_select.pulsePeriod;
      outlinePass_patch_select.visibleEdgeColor.set(outlinePass_params_select.visibleEdgeColor);
      outlinePass_patch_select.hiddenEdgeColor.set(outlinePass_params_select.visibleEdgeColor);

      effectFXAA_patch = new ShaderPass(FXAAShader);
      effectFXAA_patch.uniforms['resolution'].value.set(1 / $("#container_patch").width() / window.devicePixelRatio, 1 / window.innerHeight / 0.78 / window.devicePixelRatio);
      composer_patch.addPass(effectFXAA_patch);
      composer_patch.setPixelRatio(window.devicePixelRatio);
      composer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.78);

      controls_patch = new THREE.OrbitControls(camera_patch, renderer_patch.domElement);

      controls_patch.enableDamping = true;
      controls_patch.dampingFactor = 0.1;
      controls_patch.rotateSpeed = 0.2;
      controls_patch.screenSpacePanning = false;
      controls_patch.minDistance = 0.02;
      controls_patch.maxDistance = 1000;
      controls_patch.enableRotate = false;

      controls_patch.mouseButtons = { ORBIT: THREE.MOUSE.MIDDLE, ZOOM: false, PAN: THREE.MOUSE.RIGHT };

      // controls_patch.maxPolarAngle = Math.PI * 0.9;
      // controls_patch.minPolarAngle = Math.PI * 0.1;
      // controls_patch.maxAzimuthAngle = Math.PI * 0.4;
      // controls_patch.minAzimuthAngle = -Math.PI * 0.4;


      scene_patch.add(covered_obj_patch);

    }


    function animate() {
      stats.begin();
      if (patch_panel_width != $("#container_patch").css("width")) {
        patch_panel_width = $("#container_patch").css("width")
        onWindowResize()
      }
      if (progress_obj + progress_mtl == 200) {
        var lack = false;
        var all_empty = true;
        progress_obj = progress_mtl = -1;
        var num = garment.children[0].children.length;
        var uvs = []
        for (var i = 0; i < num; i++) {
          try {
            var empty = true;
            var uvarray = garment.children[0].children[i].geometry.attributes.uv.array
            uvs.push(uvarray);
            if (!all_empty || i == 0) {
              for (var uv_index in uvarray) {
                if (uvarray[uv_index] != 0 && uvarray[uv_index] != 1) {
                  empty = false;
                }
              }
            }
            !empty ? all_empty = false : all_empty = true;
          }
          catch (err) {
            console.warn(err + ". Using empty UVs instead.")
            lack = true
            uvs.push([]);
          }
        }
        if (lack || all_empty) { $("#alert_uv").html('<div class="alert alert-warning fade in"><a href="#" class="close" data-dismiss="alert">&times;</a><strong><b>Warning!&nbsp;</b></strong>The imported model lacks of partial UVs. This means that the patches we can get are <b>NOT</b> complete! Part of the textures may also cannot be set!&nbsp;&nbsp;</div>'); }

        patch = patch_loader(garment, uvs, 0.5, num, false);
        patch.name = "patch";
        scene_patch.add(patch);
        controls_patch.maxDistance = max_radius * 8;
        controls.maxDistance = Math.min(100, obj_size * 10);
        camera_patch.far = max_radius * 50;

        for (var i = 0; i < original.length; i++) {
          if (original[i].geometry.groups.length > 0) {
            original[i].material = original[i].material.slice(0)
          }
        }

        document.addEventListener("mousemove", mouseMove, false);

        $("#info").html("<p><font size='3'>Parafashion</font><br /><font size='1' color='#a0a0a0'>Vertices: " + obj_vertices_count + "</font></p>")
        Display(environment[gui_options.env]);
        onWindowResize();
      }
      else if (progress_obj + progress_mtl == -2) {
        // angle += Math.PI * 0.0005;
        // if (angle > Math.PI * 2) angle = Math.PI * 0.0005;
        // directionalLight.position.x = Math.sin(angle) * obj_size * 10;
        // directionalLight.position.z = Math.cos(angle) * obj_size * 10;
        // directionalLight.position.y = obj_size / 2 * 10
        // directionalLight.shadow.camera.left = -obj_size * 1;
        // directionalLight.shadow.camera.right = obj_size * 1;
        // directionalLight.shadow.camera.top = obj_size * 1;
        // directionalLight.shadow.camera.bottom = -obj_size * 1;
        // sphere.position.x = Math.sin(angle) * obj_size * 10;
        // sphere.position.z = Math.cos(angle) * obj_size * 10;
        // sphere.position.y = obj_size / 2 * 10
        // sphere.scale.set(obj_size, obj_size, obj_size)

        //****************************************************************************************
        // if (url) {
        //   if (selected.length == 2) {
        //     selected[0].material[selected[1]]=selected[0].material[selected[1]].clone();
        //     selected_patch[0].material=selected_patch[0].material.clone();
        //     updateUvTransform(selected[0].material[selected[1]]);
        //     updateUvTransform(selected_patch[0].material)
        //   }          
        //   else if (selected.length == 1) {
        //     selected[0].material=selected[0].material.clone();
        //     selected_patch[0].material=selected_patch[0].material.clone();
        //     updateUvTransform(selected[0].material);
        //     updateUvTransform(selected_patch[0].material)
        //   }
        // }
        //****************************************************************************************
      }

      $(".up-area").css({ "width": $(".dg.main").css("width") })

      requestAnimationFrame(animate);
      render();
      stats.end();
    }

    function render() {
      controls.update();
      composer.render();
      if (render_patch_flag) {
        controls_patch.update();
        composer_patch.render();
      }
    }


    function onWindowResize() {
      if (window.innerWidth < 1080) {
        $("#alert_size").html('<div class="alert alert-warning fade in"><a href="#" class="close" data-dismiss="alert">&times;</a><strong><b>Warning!&nbsp;</b></strong>Your window width is too small. This web application is <b>NOT</b> compatible!&nbsp;&nbsp;</div>');
      } else { $("#alert_size").html("") }
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth / window.devicePixelRatio, 1 / window.innerHeight / window.devicePixelRatio);

      if (render_patch_flag) {
        camera_patch.aspect = $("#container_patch").width() / window.innerHeight / 0.78;
        camera_patch.updateProjectionMatrix();
        renderer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.78);
        composer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.78);
        effectFXAA_patch.uniforms['resolution'].value.set(1 / $("#container_patch").width() / window.devicePixelRatio, 1 / window.innerHeight / 0.78 / window.devicePixelRatio);
      }
      // if (gui) {
      //   var width = Math.max(216, window.innerWidth * 0.2);
      //   gui.domElement.style.width = width + 'px';
      //   gui.__closeButton.style.width = width + 'px';
      // }
    }


    function onmouseDown(event) {
      mouse_down = true;
      if (event.button == 0 && gui_options.cut) {
        drawing = true;
      }
      else if (event.button == 0) {
        let obj = document.getElementById("panel_box");
        pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        pointer.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        pointer_patch.x = (event.clientX / (renderer_patch.domElement.clientWidth)) * 2 - 1;
        pointer_patch.y = - ((event.clientY - obj.offsetTop - document.getElementById("patch_btn").clientHeight) / (renderer_patch.domElement.clientHeight)) * 2 + 1;
        // if (event.clientX > obj.offsetLeft
        //   && event.clientX < (obj.offsetLeft + obj.clientWidth)
        //   && event.clientY > obj.offsetTop
        //   && event.clientY < (obj.offsetTop + obj.clientHeight)) {
        //   return;
        // }
        if (!mouse_down && cover) { cover_recovery(); }
        if (cover) {
          select_material(pointer, camera, pointer_patch, camera_patch);
        }
        cover = false;
      }
      else if (event.button == 1) { cover = false; }
      else if (event.button == 2) { cover = false; }
    }

    function onmouseUp(event) {
      mouse_down = false;
      if (event.button == 0 && gui_options.cut) {
        drawing = false;
      }
      else if (event.button == 0) {
        cover = true;
        cover_recovery()
      }
      else if (event.button == 1) {
        cover = true;
        cover_recovery()
      }
      else if (event.button == 2) {
        cover = true;
        cover_recovery()
      }
    }

    function mouseMove(event) {
      let obj = document.getElementById("panel_box");
      pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
      pointer.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
      pointer_patch.x = (event.clientX / (renderer_patch.domElement.clientWidth)) * 2 - 1;
      pointer_patch.y = - ((event.clientY - obj.offsetTop - document.getElementById("patch_btn").clientHeight) / (renderer_patch.domElement.clientHeight)) * 2 + 1;
      if (!mouse_down && cover) { cover_recovery(); }
      if (drawing) {
      } else if (gui_options.cut) { }
      else if (cover) {
        cover_material(pointer, camera, pointer_patch, camera_patch);
      }
    }


    function cover_recovery() {
      outlinePass.selectedObjects = []
      outlinePass_patch.selectedObjects = []
      last_cover = []
      last_cover_patch = []
    }

    function select_recovery() {
      outlinePass_select.selectedObjects = []
      outlinePass_patch_select.selectedObjects = []
      last_select = []
      last_select_patch = []
      selected = []
      selected_patch = []
    }

    function cover_material(cover_pointer, cover_camera, cover_pointer_patch, cover_camera_patch) {
      if (progress_obj + progress_mtl != -2) {
        cover_recovery();
        return;
      }
      let obj = document.getElementById("panel_box");
      if (event.clientX > obj.offsetLeft
        && event.clientX < (obj.offsetLeft + obj.clientWidth)
        && event.clientY > obj.offsetTop
        && event.clientY < (obj.offsetTop + obj.clientHeight)) {

        raycaster.setFromCamera(cover_pointer_patch, cover_camera_patch);
        const intersects = raycaster.intersectObject(patch, true);
        if (intersects.length > 0) {
          // console.log(intersects[ 0 ].face)
          // console.log(intersects[ 0 ].point)
          if (intersects[0].object.parent instanceof THREE.Group) {
            var i = 0;
            for (i = 0; i < intersects[0].object.parent.children.length; i++) {
              if (intersects[0].object.parent.children[i].name == intersects[0].object.name) { break; }
            }
            if (last_cover_patch.length != 1 || (last_cover_patch[0] != intersects[0].object)) {
              covered_obj_patch.traverse(function (obj) {
                if (obj.type === 'Mesh') {
                  obj.geometry.dispose();
                  obj.material.dispose();
                }
              })
              covered_obj.traverse(function (obj) {
                if (obj.type === 'Mesh') {
                  obj.geometry.dispose();
                  obj.material.dispose();
                }
              })
              scene_patch.remove(covered_obj_patch);
              scene.remove(covered_obj);
              var this_scale = intersects[0].object.scale;
              var this_position = intersects[0].object.position;
              var g = intersects[0].object.geometry
              covered_obj_patch = new THREE.Mesh(g);
              covered_obj_patch.material.transparent = true;
              covered_obj_patch.material.opacity = 0;
              covered_obj_patch.scale.set(this_scale.x, this_scale.y, this_scale.z);
              covered_obj_patch.position.set(this_position.x, this_position.y, this_position.z + 0.0001);
              scene_patch.add(covered_obj_patch)
              outlinePass_patch.selectedObjects = [covered_obj_patch];
              last_cover_patch = []
              last_cover_patch.push(intersects[0].object)

              garment.traverse(function (obj) {
                if (obj.type === "Mesh") {
                  if (obj.name == intersects[0].object.parent.name) {
                    var this_scale = obj.parent.scale;
                    var this_position = obj.parent.position;
                    var g = individual(obj.geometry, i)
                    covered_obj = new THREE.Mesh(g);
                    covered_obj.material.transparent = true;
                    covered_obj.material.opacity = 0;
                    covered_obj.scale.set(this_scale.x, this_scale.y, this_scale.z);
                    covered_obj.position.set(this_position.x, this_position.y, this_position.z);
                    scene.add(covered_obj)
                    outlinePass.selectedObjects = [covered_obj];
                  }
                }
              })
            }
          }
          else {
            if (last_cover_patch.length != 1 || (last_cover_patch[0] != intersects[0].object)) {
              outlinePass_patch.selectedObjects = [intersects[0].object];
              last_cover_patch = []
              last_cover_patch.push(intersects[0].object)
              garment.traverse(function (obj) {
                if (obj.type === "Mesh" && obj.name == intersects[0].object.name) {
                  outlinePass.selectedObjects = [obj];
                }
              })
            }
          }
        } else { cover_recovery() }


      } else {
        raycaster.setFromCamera(cover_pointer, cover_camera);
        const intersects = raycaster.intersectObject(garment, true);
        if (intersects.length > 0) {
          // console.log(intersects[ 0 ].face)
          // console.log(intersects[ 0 ].point)
          var group_num = intersects[0].object.geometry.groups.length;
          var vertice_index = intersects[0].face.a;
          var i = 0;
          var num = patch ? patch.children.length : 0;
          if (group_num > 0) {
            for (i = 0; i < group_num; i++) {
              if (intersects[0].object.geometry.groups[i].start <= vertice_index && (vertice_index < (intersects[0].object.geometry.groups[i].start + intersects[0].object.geometry.groups[i].count))) { break; }
            }
            if (last_cover.length != 2 || last_cover[1] != i || (last_cover[0] != intersects[0].object)) {
              covered_obj.traverse(function (obj) {
                if (obj.type === 'Mesh') {
                  obj.geometry.dispose();
                  obj.material.dispose();
                }
              })
              scene.remove(covered_obj);
              var this_scale = intersects[0].object.parent.scale;
              var this_position = intersects[0].object.parent.position;
              var g = individual(intersects[0].object.geometry, i)
              covered_obj = new THREE.Mesh(g);
              covered_obj.material.transparent = true;
              covered_obj.material.opacity = 0;
              covered_obj.scale.set(this_scale.x, this_scale.y, this_scale.z);
              covered_obj.position.set(this_position.x, this_position.y, this_position.z);
              scene.add(covered_obj)
              outlinePass.selectedObjects = [covered_obj];
              last_cover = []
              last_cover.push(intersects[0].object, i)

              for (var x = 0; x < num; x++) {
                if (patch && intersects[0].object.name == patch.children[x].name) {
                  covered_obj_patch.traverse(function (obj) {
                    if (obj.type === 'Mesh') {
                      obj.geometry.dispose();
                      obj.material.dispose();
                    }
                  })
                  scene_patch.remove(covered_obj_patch);
                  var this_scale = patch.children[x].children[i].scale;
                  var this_position = patch.children[x].children[i].position;
                  var g = patch.children[x].children[i].geometry
                  covered_obj_patch = new THREE.Mesh(g);
                  covered_obj_patch.material.transparent = true;
                  covered_obj_patch.material.opacity = 0;
                  covered_obj_patch.scale.set(this_scale.x, this_scale.y, this_scale.z);
                  covered_obj_patch.position.set(this_position.x, this_position.y, this_position.z + 0.0001);
                  scene_patch.add(covered_obj_patch)
                  outlinePass_patch.selectedObjects = [covered_obj_patch];

                  break;
                }
              }
            }
          }
          else {
            if (last_cover.length != 1 || (last_cover[0] != intersects[0].object)) {
              outlinePass.selectedObjects = [intersects[0].object];
              last_cover = []
              last_cover.push(intersects[0].object)

              for (var x = 0; x < num; x++) {
                if (patch && intersects[0].object.name == patch.children[x].name) {
                  outlinePass_patch.selectedObjects = [patch.children[x]];
                  break;
                }
              }
            }
          }
        } else { cover_recovery() }
      }
    }


    function select_material(cover_pointer, cover_camera, cover_pointer_patch, cover_camera_patch) {
      if (progress_obj + progress_mtl != -2) {
        select_recovery();
        return;
      }
      let obj = document.getElementById("panel_box");
      if (event.clientX > obj.offsetLeft
        && event.clientX < (obj.offsetLeft + obj.clientWidth)
        && event.clientY > obj.offsetTop
        && event.clientY < (obj.offsetTop + obj.clientHeight)) {
        //***************************************************************************************************************************************
        raycaster.setFromCamera(cover_pointer_patch, cover_camera_patch);
        const intersects = raycaster.intersectObject(patch, true);
        if (intersects.length > 0) {
          // console.log(intersects[ 0 ].face)
          // console.log(intersects[ 0 ].point)
          if (intersects[0].object.parent instanceof THREE.Group) {
            var i = 0;
            for (i = 0; i < intersects[0].object.parent.children.length; i++) {
              if (intersects[0].object.parent.children[i].name == intersects[0].object.name) { break; }
            }
            if (last_select_patch.length != 1 || (last_select_patch[0] != intersects[0].object)) {
              selected_patch = [intersects[0].object];
              selected_obj_patch.traverse(function (obj) {
                if (obj.type === 'Mesh') {
                  obj.geometry.dispose();
                  obj.material.dispose();
                }
              })
              selected_obj.traverse(function (obj) {
                if (obj.type === 'Mesh') {
                  obj.geometry.dispose();
                  obj.material.dispose();
                }
              })
              scene_patch.remove(selected_obj_patch);
              scene.remove(selected_obj);
              var this_scale = intersects[0].object.scale;
              var this_position = intersects[0].object.position;
              var g = intersects[0].object.geometry
              selected_obj_patch = new THREE.Mesh(g);
              selected_obj_patch.material.transparent = true;
              selected_obj_patch.material.opacity = 0;
              selected_obj_patch.scale.set(this_scale.x, this_scale.y, this_scale.z);
              selected_obj_patch.position.set(this_position.x, this_position.y, this_position.z + 0.0001);
              scene_patch.add(selected_obj_patch)
              outlinePass_patch_select.selectedObjects = [selected_obj_patch];
              last_select_patch = []
              last_select = []
              last_select_patch.push(intersects[0].object)

              garment.traverse(function (obj) {
                if (obj.type === "Mesh") {
                  if (obj.name == intersects[0].object.parent.name) {
                    selected = [obj, i]
                    var this_scale = obj.parent.scale;
                    var this_position = obj.parent.position;
                    var g = individual(obj.geometry, i)
                    selected_obj = new THREE.Mesh(g);
                    selected_obj.material.transparent = true;
                    selected_obj.material.opacity = 0;
                    selected_obj.scale.set(this_scale.x, this_scale.y, this_scale.z);
                    selected_obj.position.set(this_position.x, this_position.y, this_position.z);
                    scene.add(selected_obj)
                    outlinePass_select.selectedObjects = [selected_obj];
                  }
                }
              })
            }
          }
          else {
            if (last_select_patch.length != 1 || (last_select_patch[0] != intersects[0].object)) {
              outlinePass_patch_select.selectedObjects = [intersects[0].object];
              last_select_patch = []
              last_select = []
              last_select_patch.push(intersects[0].object)
              selected_patch = [intersects[0].object];
              garment.traverse(function (obj) {
                if (obj.type === "Mesh" && obj.name == intersects[0].object.name) {
                  outlinePass_select.selectedObjects = [obj];
                  selected = [obj];
                }
              })
            }
          }
        } //else { select_recovery() }

        //*****************************************************************************************************************************************
      } else {
        raycaster.setFromCamera(cover_pointer, cover_camera);
        const intersects = raycaster.intersectObject(garment, true);
        if (intersects.length > 0) {
          // console.log(intersects[ 0 ].face)
          // console.log(intersects[ 0 ].point)
          //console.log(intersects[0].object)
          var group_num = intersects[0].object.geometry.groups.length;
          var vertice_index = intersects[0].face.a;
          var i = 0;
          var num = patch ? patch.children.length : 0;
          if (group_num > 0) {
            for (i = 0; i < group_num; i++) {
              if (intersects[0].object.geometry.groups[i].start <= vertice_index && (vertice_index < (intersects[0].object.geometry.groups[i].start + intersects[0].object.geometry.groups[i].count))) { break; }
            }
            if (last_select.length != 2 || last_select[1] != i || last_select[0] != intersects[0].object) {
              selected = [intersects[0].object, i]
              selected_obj.traverse(function (obj) {
                if (obj.type === 'Mesh') {
                  obj.geometry.dispose();
                  obj.material.dispose();
                }
              })
              scene.remove(selected_obj);
              var this_scale = intersects[0].object.parent.scale;
              var this_position = intersects[0].object.parent.position;
              var g = individual(intersects[0].object.geometry, i)
              selected_obj = new THREE.Mesh(g);
              selected_obj.material.transparent = true;
              selected_obj.material.opacity = 0;
              selected_obj.scale.set(this_scale.x, this_scale.y, this_scale.z);
              selected_obj.position.set(this_position.x, this_position.y, this_position.z);
              scene.add(selected_obj)
              outlinePass_select.selectedObjects = [selected_obj];
              last_select = []
              last_select_patch = []
              last_select.push(intersects[0].object, i)

              for (var x = 0; x < num; x++) {
                if (patch && intersects[0].object.name == patch.children[x].name) {
                  selected_patch = [patch.children[x].children[i]];

                  selected_obj_patch.traverse(function (obj) {
                    if (obj.type === 'Mesh') {
                      obj.geometry.dispose();
                      obj.material.dispose();
                    }
                  })
                  scene_patch.remove(selected_obj_patch);
                  var this_scale = patch.children[x].children[i].scale;
                  var this_position = patch.children[x].children[i].position;
                  var g = patch.children[x].children[i].geometry
                  selected_obj_patch = new THREE.Mesh(g);
                  selected_obj_patch.material.transparent = true;
                  selected_obj_patch.material.opacity = 0;
                  selected_obj_patch.scale.set(this_scale.x, this_scale.y, this_scale.z);
                  selected_obj_patch.position.set(this_position.x, this_position.y, this_position.z + 0.0001);
                  scene_patch.add(selected_obj_patch)
                  outlinePass_patch_select.selectedObjects = [selected_obj_patch];
                  break;
                }
              }
            }
          }
          else {
            if (last_select.length != 1 || last_select[0] != intersects[0].object) {
              selected = [intersects[0].object];
              outlinePass_select.selectedObjects = [intersects[0].object];
              last_select = []
              last_select_patch = []
              last_select.push(intersects[0].object)

              for (var x = 0; x < num; x++) {
                if (patch && intersects[0].object.name == patch.children[x].name) {
                  patch.children[x].material = patch.children[x].material.clone();
                  selected_patch = [patch.children[x]];
                  outlinePass_patch_select.selectedObjects = [patch.children[x]];
                  break;
                }
              }
            }
          }
        } //else { select_recovery() }
      }
    }


    function individual(bufGeom, ig) {

      var groups = bufGeom.groups;
      var origVerts = bufGeom.getAttribute('position').array;
      var origNormals = bufGeom.getAttribute('normal').array;
      var origUVs = bufGeom.getAttribute('uv').array;
      var group = groups[ig];

      var destNumVerts = group.count;

      var newBufGeom = new THREE.BufferGeometry();
      var newPositions = new Float32Array(destNumVerts * 3);
      var newNormals = new Float32Array(destNumVerts * 3);
      var newUVs = new Float32Array(destNumVerts * 2);

      for (var iv = 0; iv < destNumVerts; iv++) {

        var indexOrig = 3 * (group.start + iv);
        var indexDest = 3 * iv;

        var indexOrigUV = 2 * (group.start + iv);
        var indexDestUV = 2 * iv;
        newPositions[indexDest] = origVerts[indexOrig];
        newPositions[indexDest + 1] = origVerts[indexOrig + 1];
        newPositions[indexDest + 2] = origVerts[indexOrig + 2];

        newNormals[indexDest] = origNormals[indexOrig];
        newNormals[indexDest + 1] = origNormals[indexOrig + 1];
        newNormals[indexDest + 2] = origNormals[indexOrig + 2];

        newUVs[indexDestUV] = origUVs[indexOrigUV];
        newUVs[indexDestUV + 1] = origUVs[indexOrigUV + 1];

      }

      newBufGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
      newBufGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
      newBufGeom.setAttribute('uv', new THREE.Float32BufferAttribute(newUVs, 2));

      return newBufGeom;

    }

    function individual_garmentToPatch(bufGeom, ig) {

      var groups = bufGeom.groups;
      var origVerts = bufGeom.getAttribute('position').array;
      var origNormals = bufGeom.getAttribute('normal').array;
      var origUVs = bufGeom.getAttribute('uv').array;
      var group = groups[ig];

      var destNumVerts = group.count;

      var newBufGeom = new THREE.BufferGeometry();
      var newPositions = new Float32Array(destNumVerts * 3);
      var newNormals = new Float32Array(destNumVerts * 3);
      var newUVs = new Float32Array(destNumVerts * 2);

      for (var iv = 0; iv < destNumVerts; iv++) {

        var indexOrig = 3 * (group.start + iv);
        var indexDest = 3 * iv;

        var indexOrigUV = 2 * (group.start + iv);
        var indexDestUV = 2 * iv;
        newPositions[indexDest] = origUVs[indexOrigUV];
        newPositions[indexDest + 1] = origUVs[indexOrigUV + 1];
        newPositions[indexDest + 2] = 0;

        newNormals[indexDest] = origNormals[indexOrig];
        newNormals[indexDest + 1] = origNormals[indexOrig + 1];
        newNormals[indexDest + 2] = origNormals[indexOrig + 2];

        newUVs[indexDestUV] = origUVs[indexOrigUV];
        newUVs[indexDestUV + 1] = origUVs[indexOrigUV + 1];

      }

      newBufGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
      newBufGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
      newBufGeom.setAttribute('uv', new THREE.Float32BufferAttribute(newUVs, 2));

      return newBufGeom;

    }


    function seperateGroups(bufGeom) {
      var outGeometries = [];
      var groups = bufGeom.groups;

      var origVerts = bufGeom.getAttribute('position').array;
      var origNormals = bufGeom.getAttribute('normal').array;
      var origUVs = bufGeom.getAttribute('uv').array;
      for (var ig = 0, ng = groups.length; ig < ng; ig++) {
        var group = groups[ig];

        var destNumVerts = group.count;

        var newBufGeom = new THREE.BufferGeometry();
        var newPositions = new Float32Array(destNumVerts * 3);
        var newNormals = new Float32Array(destNumVerts * 3);
        var newUVs = new Float32Array(destNumVerts * 2);

        for (var iv = 0; iv < destNumVerts; iv++) {

          var indexOrig = 3 * (group.start + iv);
          var indexDest = 3 * iv;

          var indexOrigUV = 2 * (group.start + iv);
          var indexDestUV = 2 * iv;

          newPositions[indexDest] = origVerts[indexOrig];
          newPositions[indexDest + 1] = origVerts[indexOrig + 1];
          newPositions[indexDest + 2] = origVerts[indexOrig + 2];

          newNormals[indexDest] = origNormals[indexOrig];
          newNormals[indexDest + 1] = origNormals[indexOrig + 1];
          newNormals[indexDest + 2] = origNormals[indexOrig + 2];

          newUVs[indexDestUV] = origUVs[indexOrigUV];
          newUVs[indexDestUV + 1] = origUVs[indexOrigUV + 1];

        }

        newBufGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
        newBufGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
        newBufGeom.setAttribute('uv', new THREE.Float32BufferAttribute(newUVs, 2));

        outGeometries.push(newBufGeom);

      }
      return outGeometries;

    }

    function seperateGroups_garmentToPatch(bufGeom) {
      var outGeometries = [];
      var groups = bufGeom.groups;

      var origVerts = bufGeom.getAttribute('position').array;
      var origNormals = bufGeom.getAttribute('normal').array;
      var origUVs = bufGeom.getAttribute('uv').array;
      for (var ig = 0, ng = groups.length; ig < ng; ig++) {
        var group = groups[ig];

        var destNumVerts = group.count;

        var newBufGeom = new THREE.BufferGeometry();
        var newPositions = new Float32Array(destNumVerts * 3);
        var newNormals = new Float32Array(destNumVerts * 3);
        var newUVs = new Float32Array(destNumVerts * 2);

        for (var iv = 0; iv < destNumVerts; iv++) {

          var indexOrig = 3 * (group.start + iv);
          var indexDest = 3 * iv;

          var indexOrigUV = 2 * (group.start + iv);
          var indexDestUV = 2 * iv;

          newPositions[indexDest] = origUVs[indexOrigUV];
          newPositions[indexDest + 1] = origUVs[indexOrigUV + 1];
          newPositions[indexDest + 2] = 0;

          newNormals[indexDest] = origNormals[indexOrig];
          newNormals[indexDest + 1] = origNormals[indexOrig + 1];
          newNormals[indexDest + 2] = origNormals[indexOrig + 2];

          newUVs[indexDestUV] = origUVs[indexOrigUV];
          newUVs[indexDestUV + 1] = origUVs[indexOrigUV + 1];

        }

        newBufGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
        newBufGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
        newBufGeom.setAttribute('uv', new THREE.Float32BufferAttribute(newUVs, 2));

        outGeometries.push(newBufGeom);

      }
      return outGeometries;

    }


    function updateUvTransform(material) {
      if (!custom_texture) return
      let custom = custom_texture.clone();
      material.needsUpdate = true;
      custom.needsUpdate = true;
      custom.wrapS = texture_wrap[TextureParams.wrap];
      custom.wrapT = texture_wrap[TextureParams.wrap];
      custom.offset.set(TextureParams.offsetX, TextureParams.offsetY);
      custom.repeat.set(TextureParams.repeatX, TextureParams.repeatY);
      custom.center.set(TextureParams.centerX, TextureParams.centerY);
      custom.rotation = TextureParams.rotation;

      material.map = custom;
    }

    function Show(Rotate) {
      if (controls !== undefined) {
        controls.autoRotate = Rotate
      }
    }


    function Display(show_env, patch_env) {
      if (show_env) {
        // sphere.visible = true
        // scene.remove(directionalLight)
        // scene.add(directionalLight);
        // renderer.shadowMap.enabled = true;
        // renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        scene.background = show_env;
        env_light.intensity = 1;
        if (garment !== undefined) {
          garment.traverse(function (child) {
            if (child.material !== undefined) {
              if (Array.isArray(child.material)) {
                child.material.forEach(function (m) {
                  if (m.envMap !== undefined) { m.envMap = show_env; }
                })
              } else {
                if (child.material.envMap !== undefined) {
                  child.material.envMap = show_env;
                }
              }
            }
          })
        }
        if (patch_env) {
          env_light_patch.intensity = 1;
          scene_patch.background = show_env;
          if (patch !== undefined) {
            patch.traverse(function (child) {
              if (child.material !== undefined) {
                if (Array.isArray(child.material)) {
                  child.material.forEach(function (m) {
                    if (m.envMap !== undefined) { m.envMap = show_env; }
                  })
                } else {
                  if (child.material.envMap !== undefined) {
                    child.material.envMap = show_env;
                  }
                }
              }
            })
          }
        } else {
          scene_patch.background = null;
          env_light_patch.intensity = 0.2;
          if (patch !== undefined) {
            patch.traverse(function (child) {
              if (child.material !== undefined) {
                if (Array.isArray(child.material)) {
                  child.material.forEach(function (m) {
                    if (m.envMap !== undefined) {
                      m.envMap = null;
                    }
                  })
                } else {
                  if (child.material.envMap !== undefined) { child.material.envMap = null; }
                }
              }
            })
          }
        }
      }
      else {
        // sphere.visible = false;
        // scene.remove(directionalLight)
        // renderer.shadowMap.enabled = false;
        scene.background = new THREE.Color(0x303030);
        env_light.intensity = 0.2;
        if (garment !== undefined) {
          garment.traverse(function (child) {
            if (child.material !== undefined) {
              if (Array.isArray(child.material)) {
                child.material.forEach(function (m) {
                  if (m.envMap !== undefined) {
                    m.envMap = null;
                  }
                })
              } else {
                if (child.material.envMap !== undefined) { child.material.envMap = null; }
              }
            }
          })
        }
        scene_patch.background = null;
        env_light_patch.intensity = 0.2;
        if (patch !== undefined) {
          patch.traverse(function (child) {
            if (child.material !== undefined) {
              if (Array.isArray(child.material)) {
                child.material.forEach(function (m) {
                  if (m.envMap !== undefined) {
                    m.envMap = null;
                  }
                })
              } else {
                if (child.material.envMap !== undefined) { child.material.envMap = null; }
              }
            }
          })
        }
      }
    }


    function obj_loader(url_obj, url_mtl, scale, double = false) {
      original=[]
      const onProgress_obj = function (xhr) {
        if (xhr.lengthComputable) {
          const percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded");
          progress_obj = Math.round(percentComplete, 2);
        }
      };
      const onProgress_mtl = function (xhr) {
        if (xhr.lengthComputable) {
          const percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded");
          progress_mtl = Math.round(percentComplete, 2);
        }
      };
      var newobj = obj3D.clone();
      var newmtl = new MTLLoader();
      if (double) {
        newmtl.setMaterialOptions({ side: THREE.DoubleSide });
        default_material.side = THREE.DoubleSide;
      }
      if (!url_mtl) {
        progress_mtl = 100
        var objLoader = new OBJLoader();
        objLoader.load(
          url_obj,
          function (root) {
            var x_max = -Infinity, x_min = Infinity, y_max = -Infinity, y_min = Infinity, z_max = -Infinity, z_min = Infinity;
            root.traverse(function (child) {
              if (child.type === 'Mesh') {
                child.name = randomString();
                original.push(child.clone())
                obj_vertices_count += child.geometry.attributes.position.count;
                child.material = []
                if (child.geometry.groups.length > 0) {
                  for (var group_i = 0; group_i < child.geometry.groups.length; group_i++) {
                    let default_m=default_material.clone()
                    default_m.map=new THREE.TextureLoader().load("./texture/default.jpg");
                    default_m.color.set(randomColor())
                    child.material.push(default_m);
                  }
                }
                else { 
                    let default_m=default_material.clone()
                    default_m.map=new THREE.TextureLoader().load("./texture/default.jpg");
                    default_m.color.set(randomColor())
                    child.material = default_m; }
                child.castShadow = true;
                child.receiveShadow = true;
                child.geometry.computeFaceNormals();
                for (var i = 0; i < child.geometry.attributes.position.array.length; i++) {
                  if ((i + 1) % 3 == 0) {
                    x_max = x_max < child.geometry.attributes.position.array[i - 2] ? child.geometry.attributes.position.array[i - 2] : x_max
                    x_min = x_min > child.geometry.attributes.position.array[i - 2] ? child.geometry.attributes.position.array[i - 2] : x_min
                    y_max = y_max < child.geometry.attributes.position.array[i - 1] ? child.geometry.attributes.position.array[i - 1] : y_max
                    y_min = y_min > child.geometry.attributes.position.array[i - 1] ? child.geometry.attributes.position.array[i - 1] : y_min
                    z_max = z_max < child.geometry.attributes.position.array[i] ? child.geometry.attributes.position.array[i] : z_max
                    z_min = z_min > child.geometry.attributes.position.array[i] ? child.geometry.attributes.position.array[i] : z_min
                  }
                }
              }
            })
            var scale_value = Math.max(x_max - x_min, y_max - y_min, z_max - z_min);
            if (scale_value > 1) { scale_value /= Math.sqrt(scale_value) }
            obj_size = Math.max(1, scale_value)
            root.position.set(-(x_min + x_max) / 2 / scale_value, -y_min / scale_value - 0.5, -(z_min + z_max) / 2 / scale_value);
            root.scale.set(scale / scale_value, scale / scale_value, scale / scale_value);
            newobj.add(root);
          },
          onProgress_obj
        );
        return newobj;
      }
      else {
        newmtl.load(
          url_mtl,
          (mtl) => {
            mtl.preload();
            var objLoader = new OBJLoader();
            objLoader.setMaterials(mtl);
            objLoader.load(
              url_obj,
              function (root) {
                var x_max = -Infinity, x_min = Infinity, y_max = -Infinity, y_min = Infinity, z_max = -Infinity, z_min = Infinity;
                root.traverse(function (child) {
                  if (child.type === 'Mesh') {
                    child.name = randomString();
                    original.push(child.clone())
                    obj_vertices_count += child.geometry.attributes.position.count;
                    if (!Array.isArray(child.material) && child.material.envMap !== undefined) { child.material.envMap = null }
                    if (child.material.map === undefined) { child.material.map = new THREE.TextureLoader().load("./texture/default.jpg"); }
                    child.castShadow = true;
                    child.receiveShadow = true;
                    child.geometry.computeFaceNormals();
                    for (var i = 0; i < child.geometry.attributes.position.array.length; i++) {
                      if ((i + 1) % 3 == 0) {
                        x_max = x_max < child.geometry.attributes.position.array[i - 2] ? child.geometry.attributes.position.array[i - 2] : x_max
                        x_min = x_min > child.geometry.attributes.position.array[i - 2] ? child.geometry.attributes.position.array[i - 2] : x_min
                        y_max = y_max < child.geometry.attributes.position.array[i - 1] ? child.geometry.attributes.position.array[i - 1] : y_max
                        y_min = y_min > child.geometry.attributes.position.array[i - 1] ? child.geometry.attributes.position.array[i - 1] : y_min
                        z_max = z_max < child.geometry.attributes.position.array[i] ? child.geometry.attributes.position.array[i] : z_max
                        z_min = z_min > child.geometry.attributes.position.array[i] ? child.geometry.attributes.position.array[i] : z_min
                      }
                    }
                  }
                })
                var scale_value = Math.max(x_max - x_min, y_max - y_min, z_max - z_min);
                if (scale_value > 1) { scale_value /= Math.sqrt(scale_value) }
                obj_size = Math.max(1, scale_value)
                root.position.set(-(x_min + x_max) / 2 / scale_value, -y_min / scale_value - 0.5, -(z_min + z_max) / 2 / scale_value);
                root.scale.set(scale / scale_value, scale / scale_value, scale / scale_value);
                newobj.add(root);
              },
              onProgress_obj
            );
          },
          onProgress_mtl
        );
        return newobj;
      }
    }

    function array_default_material_clone(array, clone) {
      var result = []
      for (var i = 0; i < array.length; i++) {
        if (array[i].envMap !== undefined) { array[i].envMap = null }
        if (array[i].map === undefined) { array[i].map = new THREE.TextureLoader().load("./texture/default.jpg"); }
        if (clone) result.push(array[i].clone())
        else result.push(array[i])
      }
      return result
    }


    function patch_loader(garment, uv, scale, num, double = false) {
      max_radius = 0;
      var first = false;
      var max_height = 0;
      var newobj = obj3D.clone();
      var last_x = -Infinity;
      var last_y = 4;
      for (var x = 0; x < num; x++) {
        var patch = garment.children[0].children[x].geometry.clone();
        var patch_mtl = Array.isArray(garment.children[0].children[x].material) ? array_default_material_clone(garment.children[0].children[x].material, true) : garment.children[0].children[x].material.clone();

        if (patch.groups && patch.groups.length > 0) {
          //var individual = seperateGroups_garmentToPatch(patch);
          var group_3d = new THREE.Group();
          for (var individual_i = 0; individual_i < patch.groups.length; individual_i++) {
            if (last_x > scale * 5) {
              last_x = -Infinity;
              last_y -= max_height * 1.5;
              max_height = 0
            }
            var individual_patch = individual_garmentToPatch(patch, individual_i)
            var vertices = [];
            var normals = [];
            var individual_uv = individual_patch.attributes.uv.array;
            for (var i = 0; i < individual_uv.length; i++) {
              if ((i + 1) % 6 == 0) {
                var x1 = individual_uv[i - 5]
                var y1 = individual_uv[i - 4]
                var x2 = individual_uv[i - 3]
                var y2 = individual_uv[i - 2]
                var x3 = individual_uv[i - 1]
                var y3 = individual_uv[i]
                var a = y3 - y1
                var b = x1 - x3
                var c = x3 * y1 - x1 * y3
                if (a * x2 + b * y2 + c >= 0) {
                  normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
                } else {
                  normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1);
                }
              }
            }
            individual_patch.deleteAttribute("normal");
            individual_patch.setAttribute("normal", new THREE.BufferAttribute(new Float32Array(normals), 3));
            var patch_map = new THREE.Mesh(individual_patch, patch_mtl[individual_i]);
            individual_patch.computeBoundingBox();
            var x_max = individual_patch.boundingBox.max.x;
            var y_max = individual_patch.boundingBox.max.y;
            var z_max = individual_patch.boundingBox.max.z;
            var x_min = individual_patch.boundingBox.min.x;
            var y_min = individual_patch.boundingBox.min.y;
            var z_min = individual_patch.boundingBox.min.z;
            var radius_x = (x_max - x_min);
            var radius_y = (y_max - y_min);
            max_radius = max_radius < radius_x * scale ? radius_x * scale : max_radius;
            max_radius = max_radius < radius_y * scale ? radius_y * scale : max_radius;
            max_height = max_height < radius_y * scale ? radius_y * scale : max_height;
            if (!first) {
              last_x = (-radius_x / 2) * scale
              last_y = (radius_y / 2) * scale
              first = (-radius_x / 2) * scale;
            }
            last_x = last_x == -Infinity ? first : last_x;
            patch_map.position.set(last_x - x_min * scale, last_y - y_max * scale, 0);
            //patch_map.rotateZ(Math.PI)
            last_x += (radius_x) * 1.5 * scale;
            patch_map.scale.set(scale, scale, scale);
            patch_map.name = randomString();
            group_3d.add(patch_map);
          }
          group_3d.name = garment.children[0].children[x].name;
          newobj.add(group_3d)
        }
        else {
          if (last_x > scale * 5) {
            last_x = -Infinity;
            last_y -= max_height * 1.5;
            max_height = 0
          }
          var vertices = [];
          var normals = [];
          for (var i = 0; i < uv[x].length; i++) {
            if ((i + 1) % 2 == 0) {
              var vertice = new THREE.Vector3();
              vertice.set(uv[x][i - 1], uv[x][i], 0);
              vertices.push(vertice);
            }
            if ((i + 1) % 6 == 0) {
              var x1 = uv[x][i - 5]
              var y1 = uv[x][i - 4]
              var x2 = uv[x][i - 3]
              var y2 = uv[x][i - 2]
              var x3 = uv[x][i - 1]
              var y3 = uv[x][i]
              var a = y3 - y1
              var b = x1 - x3
              var c = x3 * y1 - x1 * y3
              if (a * x2 + b * y2 + c >= 0) {
                normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
              } else {
                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1);
              }
            }
          }
          patch.setFromPoints(vertices);
          patch.deleteAttribute("normal");
          patch.setAttribute("normal", new THREE.BufferAttribute(new Float32Array(normals), 3));
          var patch_map = new THREE.Mesh(patch, patch_mtl);
          patch_map.name = garment.children[0].children[x].name;


          patch.computeBoundingBox();
          var x_max = patch.boundingBox.max.x;
          var y_max = patch.boundingBox.max.y;
          var z_max = patch.boundingBox.max.z;
          var x_min = patch.boundingBox.min.x;
          var y_min = patch.boundingBox.min.y;
          var z_min = patch.boundingBox.min.z;
          var radius_x = (x_max - x_min);
          var radius_y = (y_max - y_min);
          max_radius = max_radius < radius_x * scale ? radius_x * scale : max_radius;
          max_radius = max_radius < radius_y * scale ? radius_y * scale : max_radius;
          max_height = max_height < radius_y * scale ? radius_y * scale : max_height;
          if (!first) {
            last_x = (-radius_x / 2) * scale
            last_y = (radius_y / 2) * scale
            first = (-radius_x / 2) * scale;
          }
          last_x = last_x == -Infinity ? first * scale : last_x;
          patch_map.position.set(last_x - x_min * scale, last_y - y_max * scale, 0);
          //patch_map.rotateZ(Math.PI)
          last_x += radius_x * 1.5 * scale;
          patch_map.scale.set(scale, scale, scale);
          newobj.add(patch_map);
        }
      }
      if (max_radius > 1) { max_radius /= Math.sqrt(max_radius) }
      newobj.traverse(function (child) {
        if (child.type === 'Mesh') {
          child.scale.multiplyScalar(scale / max_radius)
          child.position.multiplyScalar(scale / max_radius)
        }
      })
      return newobj
    }



    function randomString(e) {
      e = e || 32;
      let t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        a = t.length,
        n = "";
      for (let i = 0; i < e; i++) n += t.charAt(Math.floor(Math.random() * a));
      return n
    }

    function randomColor() {
      return Math.random() * 0xffffff
    }

    document.querySelector('.up-area').addEventListener('click', texture_click)
    function texture_click() {
      $('#fileDrag').click();
    }
    $('#fileDrag').change((event) => {
      var files = event.target.files;
      appendFile(files, '.list-drag');
    })


    const dragbox = document.querySelector('.dragFile');
    dragbox.addEventListener('dragover', function (e) {
      e.preventDefault();
    }, false);
    dragbox.addEventListener('drop', function (e) {
      e.preventDefault();
      var files = e.dataTransfer.files;
      appendFile(files, '.list-drag')
    }, false);

    function appendFile(files, listName) {
      for (var file of files) {
        var fileType = file.type.substr(file.type.lastIndexOf("/")).toUpperCase();
        if (fileType != "/PNG" && fileType != "/JPG" && fileType != "/JPEG") {
          $("#alert_img").html('<div class="alert alert-warning fade in"><a href="#" class="close" data-dismiss="alert">&times;</a><strong><b>Warning!&nbsp;</b></strong>Only <b>JPG</b>, <b>PNG</b> or <b>JPEG</b> image file is acceptable!&nbsp;&nbsp;</div>');
          return
        }
        url = window.URL.createObjectURL(file);
        custom_texture = new THREE.TextureLoader().load(url);
        let liStr = `<img src="${url}" alt="文件" />`;
        $(listName).html(liStr);
        $(".tip").hide();
      }
    }
  </script>
</body>

</html>