<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Parafashion</title>
  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css" />
  <script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
  <script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>

<style>
  * {
    font-family: "Comic Sans MS", fantasy;
  }

  body {
    font-family: Monospace;
    background-color: #000;
    color: #fff;
    margin: 0px;
    overflow: hidden;
  }

  #info {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    user-select: none;
  }

  canvas {
    width: 100%;
    height: 100%;
  }

  div.panel_box {
    position: absolute;
    top: 10%;
    width: 20%;
    min-width: 240px;
    height: 80%;
    z-index: 2;
    text-align: center;

  }

  .btn:active.focus,
  .btn:active:focus,
  .btn:focus {
    outline: 0px auto -webkit-focus-ring-color;
    outline-offset: 2px;
  }

  #my-gui-container {
    position: absolute;
    top: 10%;
    right: 0px;
    z-index: 2;
  }
</style>

<script>
  function reactlayout() {
    if (window.innerWidth < 1250) {
      alert("Window width is too small!");
    }
  }
</script>

<body onload="reactlayout()">
  <div id="container"></div>
  <div id="my-gui-container"></div>
  <div id="panel_box" class="panel_box">

    <div class="btn-group" style="width: 100%;">
      <button id="hide-patches" type="button" class="btn btn-default" data-toggle="collapse"
        data-target="#panel-patches" style="
          background-color: rgba(182, 182, 182, 0.75);
          color: #fff;
          padding: 2px;
          width:90%;
        " onclick="hidePatches()">
        Hide Patches
      </button>
      <button id="scale-patches" type="button" class="btn btn-default" style="
          background-color: rgba(182, 182, 182, 0.75);
          color: #fff;
          padding: 2px;
          width:10%;
        " onclick="scalePatches()">
        >
      </button>
    </div>
    <div id="panel-patches" class="panel-collapse collapse in" style="background-color: rgba(0, 0, 0, 0.75)">
      <div id="container_patch">
      </div>
    </div>
  </div>
  <div id="info">
    <p>
      Parafashion<br />
      Middle button to rotate the scene, scroll to zoom in/out, right button to pan, left button to draw or select patch
    </p>
  </div>
  <script>
    function hidePatches() {
      $("#panel-patches").on("show.bs.collapse", function () {
        $("#hide-patches").text("Hide Patches");
        $("#scale-patches").css({ "color": "#fff" });
      });
      $("#panel-patches").on("hide.bs.collapse", function () {
        $("#hide-patches").text("Show Patches");
        $("#scale-patches").css({ "color": "#aaa" });
        if ($("#scale-patches").text() == "<") {
          $(".panel_box").animate({ width: '20%' }, 300, scale_icon());
        }
      });
    }
    function scalePatches() {
      if ($("#hide-patches").text() != "Show Patches" && $("#scale-patches").text() != "<") {

        if (window.innerWidth < 1250) {
          alert("Window width is too small!");
        } else { $(".panel_box").animate({ width: '80%' }, 300, scale_icon()); }
      }
      else if ($("#hide-patches").text() != "Show Patches" && $("#scale-patches").text() == "<") {
        $(".panel_box").animate({ width: '20%' }, 300, scale_icon());
      }
    }
    function scale_icon() {
      if ($("#scale-patches").text() != "<") $("#scale-patches").text("<")
      else $("#scale-patches").text(">")
    }
  </script>
  <script src="./three.js/build/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script type="module">

    import { OBJLoader } from "./three.js/examples/jsm/loaders/OBJLoader.js";
    import { MTLLoader } from "./three.js/examples/jsm/loaders/MTLLoader.js";
    import { EffectComposer } from './three.js/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from './three.js/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from './three.js/examples/jsm/postprocessing/ShaderPass.js';
    import { OutlinePass } from './three.js/examples/jsm/postprocessing/OutlinePass.js';
    import { FXAAShader } from './three.js/examples/jsm/shaders/FXAAShader.js';
    import { GUI } from './three.js/examples/jsm/libs/dat.gui.module.js';

    let camera, cameralight, controls, scene, renderer, leggin, gui, gui_values, env_light, gui_options;
    let camera_patch, cameralight_patch, controls_patch, scene_patch, renderer_patch, patch, env_light_patch;
    let drawing = false, cut = false, select = true;
    let obj3D = new THREE.Object3D();
    let progress_obj = -2, progress_mtl = -2;
    let position_folder = false;
    let patch_panel_width = $("#container_patch").css("width");
    let raycaster = new THREE.Raycaster();
    let pointer = new THREE.Vector2();
    let color = new THREE.Color();
    let covered_material;
    let covered = [], covered_patch = [];
    let mouse_down = false;
    let resizeTimer;
    let material = new THREE.MeshBasicMaterial({ color: 0x000000 });
    let loader_scale, loader_position;
    let selected_box = false;
    let box = obj3D.clone();
    let box_patch = obj3D.clone();
    let this_part = new THREE.Mesh();


    let composer, outlinePass,effectFXAA;
    let selectedObjects = [];
    let group = new THREE.Group();

    let params = {
      edgeStrength: 2.0,
      edgeGlow: 1.0,
      edgeThickness: 0.5,
      pulsePeriod: 4,
      rotate: false,
      usePatternTexture: false
    };

    init();
    init_patch();
    animate();

    function init_patch() {
      scene_patch = new THREE.Scene();
      renderer_patch = new THREE.WebGLRenderer({ alpha: true });

      renderer_patch.setPixelRatio(window.devicePixelRatio);
      renderer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.76);
      document.getElementById("container_patch").appendChild(renderer_patch.domElement);

      camera_patch = new THREE.PerspectiveCamera(
        45,
        $("#container_patch").width() / window.innerHeight / 0.76,
        0.01,
        1000
      );
      camera_patch.position.set(0, 0, 10);

      cameralight_patch = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.8);
      camera_patch.add(cameralight_patch);
      scene_patch.add(camera_patch);
      env_light_patch = new THREE.AmbientLight(0x303030);
      scene_patch.add(env_light_patch);

      controls_patch = new THREE.OrbitControls(camera_patch, renderer_patch.domElement);
      //controls.listenToKeyEvents(window); // optional

      //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

      controls_patch.enableDamping = true;
      controls_patch.dampingFactor = 0.05;
      controls.rotateSpeed = 0.1;

      controls_patch.screenSpacePanning = false;

      //controls.enablePan = false;

      controls_patch.minDistance = 0.1;
      controls_patch.maxDistance = 1000;

      controls_patch.enableRotate = false;

      // controls_patch.maxPolarAngle = Math.PI * 0.9;
      // controls_patch.minPolarAngle = Math.PI * 0.1;


      // controls_patch.maxAzimuthAngle = Math.PI * 0.4;
      // controls_patch.minAzimuthAngle = -Math.PI * 0.4;
      scene_patch.add(box_patch);

      gui_values = new (function () {
        this.garnment_x = 0;
        this.garnment_y = 0;
        this.garnment_z = 0;
        this.patch_x = 0;
        this.patch_y = 0;
        this.patch_z = 0;
        this.garnment_scale = 1;
        this.patch_scale = 1;
      })();

      gui_options = {
        Reset_Camera: function () {
          controls.reset();
          controls_patch.reset();
          gui_values.garnment_x = 0;
          gui_values.garnment_y = 0;
          gui_values.garnment_z = 0;
          gui_values.patch_x = 0;
          gui_values.patch_y = 0;
          gui_values.patch_z = 0;
          gui_values.garnment_scale = 1;
          gui_values.patch_scale = 1;
          if (position_folder) { gui.updateDisplay() }
        }
      }

    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);

      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById("container").appendChild(renderer.domElement);

      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.01,
        1000
      );
      camera.position.set(0, 0, 10);

      cameralight = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.8);
      camera.add(cameralight);
      scene.add(camera);
      env_light = new THREE.AmbientLight(0x282828);
      scene.add(env_light);


      // postprocessing
      composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);
      outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
      composer.addPass(outlinePass);
      outlinePass.edgeStrength = params.edgeStrength;
      outlinePass.edgeThickness = params.edgeThickness;
      outlinePass.edgeGlow = params.edgeGlow;
      outlinePass.pulsePeriod = params.pulsePeriod;
      outlinePass.edgeStrength = params.edgeStrength;
      outlinePass.hiddenEdgeColor.set("0xffffff")
      effectFXAA = new ShaderPass( FXAAShader );
				effectFXAA.uniforms[ 'resolution' ].value.set( 0.1 / window.innerWidth, 0.1 / window.innerHeight );
				composer.addPass( effectFXAA );
      // controls

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      //controls.listenToKeyEvents(window); // optional

      //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.1;

      controls.screenSpacePanning = false;

      //controls.enablePan = false;

      controls.minDistance = 0.1;
      controls.maxDistance = 100;


      var leggins_obj = "./leggins/leggins_patch.obj";
      var leggins_mtl = "./leggins/leggins_patch.obj.mtl";
      var leggins_mtl = "./leggins/patch.mtl"
      var leggins_obj = "./leggins/patch.obj"
      var leggins_mtl = "./obj/village1/village_final.mtl"
      var leggins_obj = "./obj/village1/village_final.obj"
      var leggins_mtl = "./obj/tower/tower1.mtl"
      var leggins_obj = "./obj/tower/tower1.obj"
      // var leggins_mtl = "./obj/city2/city2.mtl"
      // var leggins_obj = "./obj/city2/city2.obj"
      leggin = obj_loader(leggins_obj, leggins_mtl, 1, true);
      scene.add(leggin);

      scene.add(box);
      scene.add(this_part);
      //
      window.addEventListener("resize", onWindowResize);
      window.addEventListener("mousedown", onmouseDown, false);
      window.addEventListener("mouseup", onmouseUp, false);
    }

    function onmouseDown(event) {
      mouse_down = true;
      if (event.button == 0 && cut) {
        drawing = true;
      }
      else if (event.button == 1) { select = false; }
      else if (event.button == 2) { select = false; }
    }

    function onmouseUp(event) {
      mouse_down = false;
      if (event.button == 0 && cut) {
        drawing = false;
      }
      else if (event.button == 1) {
        select = true;
        material_recovery();
      }
      else if (event.button == 2) {
        select = true;
        material_recovery();
      }
    }

    function material_recovery() {
      if (covered.length == 1) {
        covered[0].material = covered_material;
        covered_patch[0].material = covered_material;
        covered = [];
        covered_patch = [];
        covered_material = false;
      }
      else if (covered.length == 2) {
        covered[0][covered[1]] = covered_material;
        //covered_patch[0][covered_patch[1]] = covered_material;
        covered = [];
        covered_patch = [];
        covered_material = false;
      }
    }

    function mouseMove(event) {
      var obj = document.getElementById("panel_box");
      pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
      pointer.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
      if (event.clientX > obj.offsetLeft
        && event.clientX < (obj.offsetLeft + obj.clientWidth)
        && event.clientY > obj.offsetTop
        && event.clientY < (obj.offsetTop + obj.clientHeight)) {
        if (!mouse_down && select) { material_recovery(); }
        return;
      }
      if (drawing) {
      }
      else if (select) {
        box.remove(...box.children);
        box_patch.remove(...box_patch.children);
        raycaster.setFromCamera(pointer, camera);
        material_recovery();
        const intersects = raycaster.intersectObject(leggin, true);
        if (intersects.length > 0) {
          // console.log(intersects[ 0 ].face)
          // console.log(intersects[ 0 ].point)
          //outlinePass.selectedObjects = [intersects[0].object];
          var material_seleted = new THREE.MeshLambertMaterial({ color: 0xff0000, side: THREE.DoubleSide });
          var group_num = intersects[0].object.geometry.groups.length;
          var vertice_index = intersects[0].face.a;
          var i = 0;
          var num = patch ? patch.children.length : 0;
          if (group_num > 0) {
            for (i = 0; i < group_num; i++) {
              if (intersects[0].object.geometry.groups[i].start <= vertice_index && (vertice_index < (intersects[0].object.geometry.groups[i].start + intersects[0].object.geometry.groups[i].count))) { break; }
            }
            covered_material = intersects[0].object.material[i].clone();
            intersects[0].object.material[i] = intersects[0].object.material[i].clone()
            var color_rgb = intersects[0].object.material[i].color;
            Math.abs(color_rgb.r - 1) + Math.abs(color_rgb.g - 0.5) + Math.abs(color_rgb.b - 0.5) > 0.3 ? intersects[0].object.material[i].color.setRGB(1, 0.5, 0.5) : intersects[0].object.material[i].color.setRGB(1.2, 0.6, 0.6)
            covered = [intersects[0].object.material, i]

            //****************************************************************************************************
            // var g_position = g.attributes.position.array.slice(g.groups[i].start, g.groups[i].start + g.groups[i].count)
            // g.deleteAttribute("position");
            // g.setAttribute("position", new THREE.BufferAttribute(g_position, 3));

            // var g_normal = g.attributes.normal.array.slice(g.groups[i].start, g.groups[i].start + g.groups[i].count)
            // g.deleteAttribute("normal");
            // g.setAttribute("normal", new THREE.BufferAttribute(g_normal, 3));

            // var g_uv = g.attributes.uv.array.slice(g.groups[i].start, g.groups[i].start + g.groups[i].count)
            // g.deleteAttribute("uv");
            // g.setAttribute("uv", new THREE.BufferAttribute(g_uv, 3));


            // box.add(new THREE.BoxHelper(intersects[0].object, 0xffffff));
            // var aaa = new THREE.Mesh(g)
            // scene.add(aaa)
            this_part.traverse(function (obj) {
              if (obj.type === 'Mesh') {
                obj.geometry.dispose();
                obj.material.dispose();
              }
            })
            scene.remove(this_part);
            var this_scale = intersects[0].object.parent.scale;
            var this_position = intersects[0].object.parent.position;
            var g = separateGroups(intersects[0].object.geometry)[i]
            this_part = new THREE.Mesh(g);
            this_part.material.transparent=true;
            this_part.material.opacity=0;
            this_part.scale.set(this_scale.x,this_scale.y,this_scale.z);
            this_part.position.set(this_position.x,this_position.y,this_position.z);
            scene.add(this_part)
            outlinePass.selectedObjects = [this_part];
            //****************************************************************************************************

            for (var x = 0; x < num; x++) {
              if (patch && intersects[0].object.name == patch.children[x].name) {
                covered_patch = [patch.children[x].material, i];
                patch.children[x].geometry.computeBoundingSphere();

                //****************************************************************************************************
                //box_patch.add(new THREE.BoxHelper(patch.children[x], 0xffffff));
                //****************************************************************************************************

                break;
              }
            }
          }
          else {
            covered_material = intersects[0].object.material.clone();
            intersects[0].object.material = intersects[0].object.material.clone();
            var color_rgb = intersects[0].object.material.color;
            Math.abs(color_rgb.r - 1) + Math.abs(color_rgb.g - 0.5) + Math.abs(color_rgb.b - 0.5) > 0.3 ? intersects[0].object.material.color.setRGB(1, 0.5, 0.5) : intersects[0].object.material.color.setRGB(1.2, 0.6, 0.6);
            covered = [intersects[0].object];


            //****************************************************************************************************
            //box.add(new THREE.BoxHelper(intersects[0].object, 0xffffff));
            outlinePass.selectedObjects = [intersects[0].object];
            //****************************************************************************************************

            for (var x = 0; x < num; x++) {
              if (patch && intersects[0].object.name == patch.children[x].name) {
                patch.children[x].material = patch.children[x].material.clone();
                Math.abs(color_rgb.r - 1) + Math.abs(color_rgb.g - 0.5) + Math.abs(color_rgb.b - 0.5) > 0.3 ? patch.children[x].material.color.setRGB(1, 0.5, 0.5) : patch.children[x].material.color.setRGB(1.2, 0.6, 0.6);
                covered_patch = [patch.children[x]];

                //****************************************************************************************************
                //box_patch.add(new THREE.BoxHelper(patch.children[x], 0xffffff));
                //****************************************************************************************************

                break;
              }
            }
          }
        }
      }
    }

    function separateGroups(bufGeom) {

      var outGeometries = [];

      var groups = bufGeom.groups;

      var origVerts = bufGeom.getAttribute('position').array;
      var origNormals = bufGeom.getAttribute('normal').array;
      var origNumVerts = Math.floor(origVerts.length / 3);

      for (var ig = 0, ng = groups.length; ig < ng; ig++) {

        var group = groups[ig];

        var destNumVerts = group.count;

        var newBufGeom = new THREE.BufferGeometry();
        var newPositions = new Float32Array(destNumVerts * 3);
        var newNormals = new Float32Array(destNumVerts * 3);

        for (var iv = 0; iv < destNumVerts; iv++) {

          var indexOrig = 3 * (group.start + iv);
          var indexDest = 3 * iv;

          newPositions[indexDest] = origVerts[indexOrig];
          newPositions[indexDest + 1] = origVerts[indexOrig + 1];
          newPositions[indexDest + 2] = origVerts[indexOrig + 2];

          newNormals[indexDest] = origNormals[indexOrig];
          newNormals[indexDest + 1] = origNormals[indexOrig + 1];
          newNormals[indexDest + 2] = origNormals[indexOrig + 2];

        }

        newBufGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
        newBufGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));

        outGeometries.push(newBufGeom);

      }

      return outGeometries;

    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      effectFXAA.uniforms[ 'resolution' ].value.set( 0.1 / window.innerWidth, 0.1 / window.innerHeight );

      camera_patch.aspect = $("#container_patch").width() / window.innerHeight / 0.76;
      camera_patch.updateProjectionMatrix();
      renderer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.76);
      if (position_folder) {
        var width = Math.max(250, window.innerWidth * 0.2);
        gui.domElement.style.width = width + 'px';
        gui.__closeButton.style.width = width + 'px';
      }
    }

    function animate() {
      if (patch_panel_width != $("#container_patch").css("width")) {
        patch_panel_width = $("#container_patch").css("width")
        onWindowResize()
      }
      if (progress_obj + progress_mtl == 200) {
        var lack = false;
        var all_empty = true;
        progress_obj = progress_mtl = -1;
        var num = leggin.children[0].children.length;
        var uvs = []
        for (var i = 0; i < num; i++) {
          try {
            var empty = true;
            var uvarray = leggin.children[0].children[i].geometry.attributes.uv.array
            uvs.push(uvarray);
            if (!all_empty || i == 0) {
              for (var uv_index in uvarray) {
                if (uvarray[uv_index] != 0 && uvarray[uv_index] != 1) {
                  empty = false;
                }
              }
            }
            !empty ? all_empty = false : all_empty = true;
          }
          catch (err) {
            console.warn(err + ". Using empty UVs instead.")
            lack = true
            uvs.push([]);
          }
        }
        if (lack || all_empty) { alert("The imported model lacks of partial UVs. This means that the patches we can get are may not complete!") }

        patch = patch_loader(leggin, uvs, "./leggins/leggins_patch.obj.mtl", 3, num, false);
        patch.name = "patch"
        scene_patch.add(patch)

        document.addEventListener("mousemove", mouseMove, false);

        if (!position_folder) {
          gui = new GUI({ width: Math.max(250, window.innerWidth * 0.2), autoPlace: false })
          // position_folder = gui.addFolder("Position and Scale")
          // position_folder.add(gui_values, "garnment_x", -10, 10, 0.01)
          // position_folder.add(gui_values, "garnment_y", -10, 10, 0.01)
          // position_folder.add(gui_values, "garnment_z", -10, 10, 0.01)
          // position_folder.add(gui_values, "garnment_scale", 0.1, 10, 0.01)
          // position_folder.add(gui_values, "patch_x", -10, 10, 0.01)
          // position_folder.add(gui_values, "patch_y", -10, 10, 0.01)
          // position_folder.add(gui_values, "patch_z", -10, 10, 0.01)
          // position_folder.add(gui_values, "patch_scale", 0.1, 10, 0.01)
          gui.add(gui_options, 'Reset_Camera');

          document.getElementById('my-gui-container').appendChild(gui.domElement);
          //position_folder.open();
        }

      }
      if (progress_obj + progress_mtl == -2) {
        leggin.position.set(gui_values.garnment_x, gui_values.garnment_y, gui_values.garnment_z)
        patch.position.set(gui_values.patch_x, gui_values.patch_y, gui_values.patch_z)
        leggin.scale.set(gui_values.garnment_scale, gui_values.garnment_scale, gui_values.garnment_scale)
        patch.scale.set(gui_values.patch_scale, gui_values.patch_scale, gui_values.patch_scale)
      }



      requestAnimationFrame(animate);
      controls.update();
      controls_patch.update();
      render();
    }

    function render() {
      composer.render();
      renderer_patch.render(scene_patch, camera_patch);
    }


    function obj_loader(url_obj, url_mtl, scale, double = false) {
      const onProgress_obj = function (xhr) {
        if (xhr.lengthComputable) {
          const percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded");
          progress_obj = Math.round(percentComplete, 2);
        }
      };
      const onProgress_mtl = function (xhr) {
        if (xhr.lengthComputable) {
          const percentComplete = (xhr.loaded / xhr.total) * 100;
          console.log(Math.round(percentComplete, 2) + "% downloaded");
          progress_mtl = Math.round(percentComplete, 2);
        }
      };
      var newobj = obj3D.clone();
      var newmtl = new MTLLoader();
      if (double) {
        newmtl.setMaterialOptions({ side: THREE.DoubleSide });
      }
      newmtl.load(
        url_mtl,
        (mtl) => {
          mtl.preload();
          var objLoader = new OBJLoader();
          objLoader.setMaterials(mtl);
          objLoader.load(
            url_obj,
            function (root) {
              var x_max = 0, x_min = 0, y_max = 0, y_min = 0, z_max = 0, z_min = 0;
              root.traverse(function (child) {
                if (child.geometry) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                  child.geometry.computeFaceNormals();
                  for (var i = 0; i < child.geometry.attributes.position.array.length; i++) {
                    if ((i + 1) % 3 == 0) {
                      x_max = x_max < child.geometry.attributes.position.array[i - 2] ? child.geometry.attributes.position.array[i - 2] : x_max
                      x_min = x_min > child.geometry.attributes.position.array[i - 2] ? child.geometry.attributes.position.array[i - 2] : x_min
                      y_max = y_max < child.geometry.attributes.position.array[i - 1] ? child.geometry.attributes.position.array[i - 1] : y_max
                      y_min = y_min > child.geometry.attributes.position.array[i - 1] ? child.geometry.attributes.position.array[i - 1] : y_min
                      z_max = z_max < child.geometry.attributes.position.array[i] ? child.geometry.attributes.position.array[i] : z_max
                      z_min = z_min > child.geometry.attributes.position.array[i] ? child.geometry.attributes.position.array[i] : z_min
                    }
                  }
                }
              })
              var scale_value = Math.max(x_max - x_min, y_max - y_min, z_max - z_min) / 5
              root.position.set(-(x_min + x_max) / 2 / scale_value, -(y_min + y_max) / 2 / scale_value - (y_max - y_min) / 20 / scale_value, -(z_min + z_max) / 2 / scale_value);
              root.scale.set(scale / scale_value, scale / scale_value, scale / scale_value);
              loader_position = root.position.clone();
              loader_scale = root.scale.clone();
              newobj.add(root);
            },
            onProgress_mtl
          );
        },
        onProgress_obj
      );
      return newobj;
    }

    function array_clone(array, clone) {
      var result = []
      for (var i = 0; i < array.length; i++) {
        if (clone) result.push(array[i].clone())
        else result.push(array[i])
      }
      return result
    }


    function patch_loader(leggin, uv, url_mtl, scale, num, double = false) {
      var newobj = obj3D.clone();
      var last_x = 0;
      for (var x = 0; x < num; x++) {
        var patch = Array.isArray(leggin.children[0].children[x].geometry) ? array_clone(leggin.children[0].children[x].geometry, true) : leggin.children[0].children[x].geometry.clone();
        var patch_mtl = leggin.children[0].children[x].material;

        var vertices = [];
        var normals = [];
        for (var i = 0; i < uv[x].length; i++) {
          if ((i + 1) % 2 == 0) {
            var vertice = new THREE.Vector3();
            vertice.set(uv[x][i - 1], uv[x][i], 0);
            vertices.push(vertice);
          }
          if ((i + 1) % 6 == 0) {
            var x1 = uv[x][i - 5]
            var y1 = uv[x][i - 4]
            var x2 = uv[x][i - 3]
            var y2 = uv[x][i - 2]
            var x3 = uv[x][i - 1]
            var y3 = uv[x][i]
            var a = y3 - y1
            var b = x1 - x3
            var c = x3 * y1 - x1 * y3
            if (a * x2 + b * y2 + c >= 0) {
              normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
            } else {
              normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1);
            }
          }
        }
        patch.setFromPoints(vertices);
        patch.deleteAttribute("normal");
        patch.setAttribute("normal", new THREE.BufferAttribute(new Float32Array(normals), 3));
        var patch_map = new THREE.Mesh(patch, patch_mtl);
        patch_map.name = leggin.children[0].children[x].name;

        patch.computeBoundingSphere();
        var radius = patch.boundingSphere.radius * 2;

        last_x = last_x == 0 ? -radius * scale : last_x;
        patch_map.position.set(radius / 2 * scale + last_x, -patch.boundingSphere.center.y * scale, 0);
        //patch_map.rotateZ(Math.PI)
        last_x += radius * 1.5 * scale;
        patch_map.scale.set(scale, scale, scale);


        newobj.add(patch_map);
      }
      return newobj
    }
  </script>
</body>

</html>