<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Parafashion</title>
  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css" />
  <script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
  <script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>

<style>
  * {
    font-family: "Comic Sans MS", fantasy;
  }

  body {
    font-family: Monospace;
    background-color: #000;
    color: #fff;
    margin: 0px;
    overflow: hidden;
  }

  #info {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    user-select: none;
  }

  canvas {
    width: 100%;
    height: 100%;
  }

  div.panel_box {
    position: absolute;
    top: 10%;
    width: 20%;
    min-width: 240px;
    height: 80%;
    z-index: 2;
    text-align: center;

  }

  .btn:active.focus,
  .btn:active:focus,
  .btn:focus {
    outline: 0px auto -webkit-focus-ring-color;
    outline-offset: 2px;
  }

  #my-gui-container {
    position: absolute;
    top: 10%;
    right: 0px;
    z-index: 2;
  }
</style>

<script>
  function reactlayout() {
    if (window.innerWidth < 1250) {
      alert("Window width is too small!");
    }
  }
</script>

<body onload="reactlayout()">
  <div id="container"></div>
  <div id="my-gui-container"></div>
  <div id="panel_box" class="panel_box">

    <div class="btn-group" style="width: 100%;">
      <button id="hide-patches" type="button" class="btn btn-default" data-toggle="collapse"
        data-target="#panel-patches" style="
          background-color: rgba(182, 182, 182, 0.75);
          color: #fff;
          padding: 2px;
          width:90%;
        " onclick="hidePatches()">
        Hide Patches
      </button>
      <button id="scale-patches" type="button" class="btn btn-default" style="
          background-color: rgba(182, 182, 182, 0.75);
          color: #fff;
          padding: 2px;
          width:10%;
        " onclick="scalePatches()">
        >
      </button>
    </div>
    <div id="panel-patches" class="panel-collapse collapse in" style="background-color: rgba(0, 0, 0, 0.75)">
      <div id="container_patch">
      </div>
    </div>
  </div>
  <div id="info">
    <p>
      Parafashion<br />
      Middle button to rotate the scene, scroll to zoom in/out, right button to pan, left button to draw or select patch
    </p>
  </div>
  <script>
    function hidePatches() {
      $("#panel-patches").on("show.bs.collapse", function () {
        $("#hide-patches").text("Hide Patches");
        $("#scale-patches").css({ "color": "#fff" });
      });
      $("#panel-patches").on("hide.bs.collapse", function () {
        $("#hide-patches").text("Show Patches");
        $("#scale-patches").css({ "color": "#aaa" });
        if ($("#scale-patches").text() == "<") {
          $(".panel_box").animate({ width: '20%' }, 300, scale_icon());
        }
      });
    }
    function scalePatches() {
      if ($("#hide-patches").text() != "Show Patches" && $("#scale-patches").text() != "<") {
        
    if (window.innerWidth < 1250) {
      alert("Window width is too small!");
    }else {$(".panel_box").animate({ width: '80%' }, 300, scale_icon());}
      }
      else if ($("#hide-patches").text() != "Show Patches" && $("#scale-patches").text() == "<") {
        $(".panel_box").animate({ width: '20%' }, 300, scale_icon());
      }
    }
    function scale_icon() {
      if ($("#scale-patches").text() != "<") $("#scale-patches").text("<")
      else $("#scale-patches").text(">")
    }
  </script>
  <script src="js/three.js"></script>
  <script src="js/OBJLoader.js"></script>
  <script src="js/MTLLoader.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script type="module">
      import { GUI } from "./js/dat.gui.module.js";
      let camera, cameralight, controls, scene, renderer, leggin, gui, gui_values, env_light, gui_options;
      let camera_patch, cameralight_patch, controls_patch, scene_patch, renderer_patch, patch, env_light_patch;
      let draw = false, cut = false, select = true;
      let obj3D = new THREE.Object3D();
      let progress_obj = -2,
        progress_mtl = -2;
      let position_folder = false;
      let patch_panel_width = $("#container_patch").css("width");
      let raycaster = new THREE.Raycaster();
      let pointer = new THREE.Vector2();
      let color = new THREE.Color();
      let selected_material;
      let selected = [], selected_patch = [];
      let mouse_down = false;
      let resizeTimer;
      let material=new THREE.MeshBasicMaterial({color:0x000000});
      let loader_scale,loader_position;
      

      init();
      init_patch();
      animate();

      function init_patch() {
        scene_patch = new THREE.Scene();
        renderer_patch = new THREE.WebGLRenderer({ alpha: true });

        renderer_patch.setPixelRatio(window.devicePixelRatio);
        renderer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.76);
        document.getElementById("container_patch").appendChild(renderer_patch.domElement);

        camera_patch = new THREE.PerspectiveCamera(
          45,
          $("#container_patch").width() / window.innerHeight / 0.76,
          0.01,
          100
        );
        camera_patch.position.set(0, 0, 3);

        cameralight_patch = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.8);
        camera_patch.add(cameralight_patch);
        scene_patch.add(camera_patch);
        env_light_patch = new THREE.AmbientLight(0x282828);
        scene_patch.add(env_light_patch);

        controls_patch = new THREE.OrbitControls(camera_patch, renderer_patch.domElement);
        //controls.listenToKeyEvents(window); // optional

        //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

        controls_patch.enableDamping = true;
        controls_patch.dampingFactor = 0.5;

        controls_patch.screenSpacePanning = false;

        //controls.enablePan = false;

        controls_patch.minDistance = 0.5;
        controls_patch.maxDistance = 100;

        controls_patch.enableRotate = false;

        // controls_patch.maxPolarAngle = Math.PI * 0.9;
        // controls_patch.minPolarAngle = Math.PI * 0.1;


        // controls_patch.maxAzimuthAngle = Math.PI * 0.4;
        // controls_patch.minAzimuthAngle = -Math.PI * 0.4;


        gui_values = new (function () {
          this.garnment_x = 0;
          this.garnment_y = 0;
          this.garnment_z = 0;
          this.patch_x = 0;
          this.patch_y = 0;
          this.patch_z = 0;
          this.garnment_scale = 1;
          this.patch_scale = 1;
        })();

        gui_options = {
          reset: function () {
            controls.reset();
            controls_patch.reset();
            gui_values.garnment_x = 0;
            gui_values.garnment_y = 0;
            gui_values.garnment_z = 0;
            gui_values.patch_x = 0;
            gui_values.patch_y = 0;
            gui_values.patch_z = 0;
            gui_values.garnment_scale = 1;
            gui_values.patch_scale = 1;
            if (position_folder) { gui.updateDisplay() }
          }
        }

      }

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);
        //document.body.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 10);

        cameralight = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.8);
        camera.add(cameralight);
        scene.add(camera);
        env_light = new THREE.AmbientLight(0x282828);
        scene.add(env_light);
        // controls

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        //controls.listenToKeyEvents(window); // optional

        //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

        controls.enableDamping = true;
        controls.dampingFactor = 0.5;

        controls.screenSpacePanning = false;

        //controls.enablePan = false;

        controls.minDistance = 0.5;
        controls.maxDistance = 100;


        var leggins_obj = "./leggins/leggins_patch.obj";
        var leggins_mtl = "./leggins/leggins_patch.obj.mtl";
        var leggins_mtl_texture = "./leggins/"
        var leggins_mtl = "./leggins/patch.mtl"
        var leggins_obj = "./leggins/patch.obj"
        var leggins_mtl_texture = "./leggins/"
        var leggins_mtl = "./obj/village1/village_final.mtl"
        var leggins_obj = "./obj/village1/village_final.obj"
        var leggins_mtl_texture = "./obj/village1/"
        var leggins_mtl = "./obj/tower/tower1.mtl"
        var leggins_obj = "./obj/tower/tower1.obj"
        var leggins_mtl_texture = "./obj/tower/"
        leggin = obj_loader(leggins_obj, leggins_mtl, leggins_mtl_texture, 1, true);
        scene.add(leggin);

        //
        window.addEventListener("resize", onWindowResize);
        window.addEventListener("mousedown", onmouseDown, false);
        window.addEventListener("mouseup", onmouseUp, false);
      }

      function onmouseDown(event) {
        mouse_down = true;
        if (event.button == 0 && cut) {
          draw = true;
        }
        else if (event.button == 1) { select = false; }
        else if (event.button == 2) { select = false; }
      }

      function onmouseUp(event) {
        mouse_down = false;
        if (event.button == 0 && cut) {
          draw = false;
        }
        else if (event.button == 1) {
          select = true;
          material_recovery();
        }
        else if (event.button == 2) {
          select = true;
          material_recovery();
        }
      }

      function material_recovery() {
        if (selected.length == 1) {
          selected[0].material = selected_material;
          selected_patch[0].material = selected_material;
          selected = [];
          selected_patch = [];
        }
        else if (selected.length == 2) {
          selected[0][selected[1]] = selected_material;
          //selected_patch[0][selected_patch[1]] = selected_material;
          selected = [];
          selected_patch = [];
        }
      }

      function mouseMove(event) {
        var obj = document.getElementById("panel_box");
        pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        pointer.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
        if (event.clientX > obj.offsetLeft
          && event.clientX < (obj.offsetLeft + obj.clientWidth)
          && event.clientY > obj.offsetTop
          && event.clientY < (obj.offsetTop + obj.clientHeight)) {
          if (!mouse_down && select) { material_recovery(); }
          return;
        }
        if (draw) {
        }
        else if (select) {
          raycaster.setFromCamera(pointer, camera);
          material_recovery();
          const intersects = raycaster.intersectObject(leggin, true);
          if (intersects.length > 0) {
            //console.log(intersects[ 0 ].face.normal)
            // console.log(intersects[ 0 ].point)
            var material_seleted = new THREE.MeshLambertMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            var group_num = intersects[0].object.geometry.groups.length;
            var vertice_index = intersects[0].face.a;
            var i = 0;
            var num = patch ? patch.children.length : 0;
            // var cover_color = -0.2;
            if (group_num > 0) {
              for (i = 0; i < group_num; i++) {
                if (intersects[0].object.geometry.groups[i].start <= vertice_index && (vertice_index < (intersects[0].object.geometry.groups[i].start + intersects[0].object.geometry.groups[i].count))) { break; }
              }
              selected_material = intersects[0].object.material[i].clone();
              // if (intersects[0].object.material[i].color.r + intersects[0].object.material[i].color.g + intersects[0].object.material[i].color.b > 2) { cover_color = -0.2; }
              // else { cover_color = 0.2; }
              intersects[0].object.material[i] = intersects[0].object.material[i].clone()
              intersects[0].object.material[i].color.setRGB(0.8,0.2,0.2);
              selected = [intersects[0].object.material, i]




//****************************************************************************************************


// var g=intersects[0].object.geometry.clone()
//               var g_position=g.attributes.position.array.slice(g.groups[i].start,g.groups[i].start + g.groups[i].count)
//               g.removeAttribute("position");
//               g.addAttribute("position", new THREE.BufferAttribute(g_position, 3));
//               g.computeBoundingBox();
// var b_box=g.boundingBox;
// b_box.min=new THREE.Vector3(b_box.min.x*loader_scale.x+loader_position.x,b_box.min.y*loader_scale.y+loader_position.y,b_box.min.z*loader_scale.z+loader_position.z)
// b_box.max=new THREE.Vector3(b_box.max.x*loader_scale.x+loader_position.x,b_box.max.y*loader_scale.y+loader_position.y,b_box.max.z*loader_scale.z+loader_position.z)
// const box = new THREE.Box3Helper( b_box, 0xffffff );
// scene.add( box );
//****************************************************************************************************



              for (var x = 0; x < num; x++) {
                if (patch && intersects[0].object.name == patch.children[x].name) {
                  selected_patch = [patch.children[x].material, i];
                  break;
                }
              }
            }
            else {
              selected_material = intersects[0].object.material.clone();
              // if (intersects[0].object.material.color.r + intersects[0].object.material.color.g + intersects[0].object.material.color.b > 2) { cover_color = -0.2; }
              // else { cover_color = 0.2; }
              intersects[0].object.material = intersects[0].object.material.clone();
              intersects[0].object.material.color.setRGB(0.8,0.2,0.2);
              selected = [intersects[0].object];


//****************************************************************************************************
// const box = new THREE.BoxHelper( intersects[0].object, 0xffffff );
// scene.add( box );


//****************************************************************************************************
              for (var x = 0; x < num; x++) {
                if (patch && intersects[0].object.name == patch.children[x].name) {
                  patch.children[x].material = patch.children[x].material.clone();
                  patch.children[x].material.color.setRGB(0.8,0.2,0.2);
                  selected_patch = [patch.children[x]];
                  break;
                }
              }
            }
          }
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera_patch.aspect = $("#container_patch").width() / window.innerHeight / 0.76;
        camera_patch.updateProjectionMatrix();
        renderer_patch.setSize($("#container_patch").width(), window.innerHeight * 0.76);
        if (position_folder) {
          var width = Math.max(250, window.innerWidth * 0.2);
          gui.domElement.style.width = width + 'px';
          gui.__closeButton.style.width = width + 'px';
        }
      }

      function animate() {
        if (patch_panel_width != $("#container_patch").css("width")) {
          patch_panel_width = $("#container_patch").css("width")
          onWindowResize()
        }
        if (progress_obj + progress_mtl == 200) {
          progress_obj = progress_mtl = -1;
          var num = leggin.children[0].children.length;
          var uvs = []
          for (var i = 0; i < num; i++) {
            uvs.push(leggin.children[0].children[i].geometry.attributes.uv.array);
          }
          patch = patch_loader(leggin, uvs, "./leggins/leggins_patch.obj.mtl", 1, num, false);
          patch.name = "patch"
          scene_patch.add(patch)

          document.addEventListener("mousemove", mouseMove, false);

          if (!position_folder) {
            gui = new GUI({ width: Math.max(250,window.innerWidth * 0.2), autoPlace: false })
            position_folder = gui.addFolder("Position and Scale")
            position_folder.add(gui_values, "garnment_x", -10, 10, 0.01)
            position_folder.add(gui_values, "garnment_y", -10, 10, 0.01)
            position_folder.add(gui_values, "garnment_z", -10, 10, 0.01)
            position_folder.add(gui_values, "garnment_scale", 0.1, 10, 0.01)
            position_folder.add(gui_values, "patch_x", -10, 10, 0.01)
            position_folder.add(gui_values, "patch_y", -10, 10, 0.01)
            position_folder.add(gui_values, "patch_z", -10, 10, 0.01)
            position_folder.add(gui_values, "patch_scale", 0.1, 10, 0.01)
            position_folder.add(gui_options, 'reset');

            document.getElementById('my-gui-container').appendChild(gui.domElement);
            position_folder.open();
          }

        }
        if (progress_obj + progress_mtl == -2) {
          leggin.position.set(gui_values.garnment_x, gui_values.garnment_y, gui_values.garnment_z)
          patch.position.set(gui_values.patch_x, gui_values.patch_y, gui_values.patch_z)
          leggin.scale.set(gui_values.garnment_scale, gui_values.garnment_scale, gui_values.garnment_scale)
          patch.scale.set(gui_values.patch_scale, gui_values.patch_scale, gui_values.patch_scale)
        }



        requestAnimationFrame(animate);
        controls.update();
        controls_patch.update();
        render();
      }

      function render() {
        renderer.render(scene, camera);
        renderer_patch.render(scene_patch, camera_patch);
      }


      function obj_loader(url_obj, url_mtl, url_mtl_texture, scale, double = false) {
        const onProgress_obj = function (xhr) {
          if (xhr.lengthComputable) {
            const percentComplete = (xhr.loaded / xhr.total) * 100;
            console.log(Math.round(percentComplete, 2) + "% downloaded");
            progress_obj = Math.round(percentComplete, 2);
          }
        };
        const onProgress_mtl = function (xhr) {
          if (xhr.lengthComputable) {
            const percentComplete = (xhr.loaded / xhr.total) * 100;
            console.log(Math.round(percentComplete, 2) + "% downloaded");
            progress_mtl = Math.round(percentComplete, 2);
          }
        };
        var newobj = obj3D.clone();
        var newmtl = new THREE.MTLLoader();
        newmtl.setTexturePath(url_mtl_texture);
        if (double) {
          newmtl.setMaterialOptions({ side: THREE.DoubleSide });
        }
        newmtl.load(
          url_mtl,
          (mtl) => {
            mtl.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(mtl);
            objLoader.load(
              url_obj,
              (root) => {
                var x_max = 0, x_min = 0, y_max = 0, y_min = 0, z_max = 0, z_min = 0;
                for (var k = 0; k < root.children.length; k++) {
                  root.children[k].castShadow = true;
                  root.children[k].receiveShadow = true;
                  root.children[k].geometry.computeFaceNormals();
                  for (var i = 0; i < root.children[k].geometry.attributes.position.array.length; i++) {
                    if ((i + 1) % 3 == 0) {
                      x_max = x_max < root.children[k].geometry.attributes.position.array[i - 2] ? root.children[k].geometry.attributes.position.array[i - 2] : x_max
                      x_min = x_min > root.children[k].geometry.attributes.position.array[i - 2] ? root.children[k].geometry.attributes.position.array[i - 2] : x_min
                      y_max = y_max < root.children[k].geometry.attributes.position.array[i - 1] ? root.children[k].geometry.attributes.position.array[i - 1] : y_max
                      y_min = y_min > root.children[k].geometry.attributes.position.array[i - 1] ? root.children[k].geometry.attributes.position.array[i - 1] : y_min
                      z_max = z_max < root.children[k].geometry.attributes.position.array[i] ? root.children[k].geometry.attributes.position.array[i] : z_max
                      z_min = z_min > root.children[k].geometry.attributes.position.array[i] ? root.children[k].geometry.attributes.position.array[i] : z_min
                    }
                  }
                }
                var scale_value = Math.max(x_max - x_min, y_max - y_min, z_max - z_min) / 5
                root.position.set(-(x_min + x_max) / 2 / scale_value, -(y_min + y_max) / 2 / scale_value - (y_max - y_min) / 20 / scale_value, -(z_min + z_max) / 2 / scale_value);
                root.scale.set(scale / scale_value, scale / scale_value, scale / scale_value);
                loader_position=root.position.clone();
                loader_scale=root.scale.clone();
                newobj.add(root);
              },
              onProgress_mtl
            );
          },
          onProgress_obj
        );
        return newobj;
      }

      function array_clone(array, clone) {
        var result = []
        for (var i = 0; i < array.length; i++) {
          if (clone) result.push(array[i].clone())
          else result.push(array[i])
        }
        return result
      }

      function patch_loader(leggin, uv, url_mtl, scale, num, double = false) {
        var newobj = obj3D.clone();
        var last_x = 0;
        for (var x = 0; x < num; x++) {
          var u_max = 0, u_min = 0, v_max = 0, v_min = 0;
          var patch = Array.isArray(leggin.children[0].children[x].geometry) ? array_clone(leggin.children[0].children[x].geometry, true) : leggin.children[0].children[x].geometry.clone();
          var patch_mtl = leggin.children[0].children[x].material;

          var vertices = [];
          var normals = [];
          for (var i = 0; i < uv[x].length; i++) {
            if ((i + 1) % 2 == 0) {
              u_max = u_max < -uv[x][i - 1] ? -uv[x][i - 1] : u_max
              u_min = u_min > -uv[x][i - 1] ? -uv[x][i - 1] : u_min
              v_max = v_max < -uv[x][i] ? -uv[x][i] : v_max
              v_min = v_min > -uv[x][i] ? -uv[x][i] : v_min
              var vertice = new THREE.Vector3();
              vertice.set(uv[x][i - 1], uv[x][i], 0);
              vertices.push(vertice);
            }
            if ((i + 1) % 6 == 0) {
              var x1 = uv[x][i - 5]
              var y1 = uv[x][i - 4]
              var x2 = uv[x][i - 3]
              var y2 = uv[x][i - 2]
              var x3 = uv[x][i - 1]
              var y3 = uv[x][i]
              var a = y3 - y1
              var b = x1 - x3
              var c = x3 * y1 - x1 * y3
              if (a * x2 + b * y2 + c >= 0) {
                normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1);
              } else {
                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1);
              }
            }
          }
          patch.setFromPoints(vertices);
          patch.removeAttribute("normal");
          patch.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(normals), 3));
          var patch_map = new THREE.Mesh(patch, patch_mtl);
          patch_map.name = leggin.children[0].children[x].name;
          last_x = last_x == 0 ? -(u_max - u_min) : last_x;
          patch_map.position.set((u_max - u_min) / 2 + last_x, -(v_max - v_min) / 2, 0);
          //patch_map.rotateZ(Math.PI)
          last_x += (u_max - u_min) * 1.5
          patch_map.scale.set(scale, scale, scale);
          newobj.add(patch_map);
        }
        return newobj
      }
  </script>
</body>

</html>